{
  "Home": {
    "title": "박훈일",
    "subtitle": "프론트엔드 개발자",
    "description": "깔끔하고 정교한 웹 경험을 만듭니다",
    "comingSoon": "더 많은 섹션이 곧 추가됩니다"
  },
  "Navigation": {
    "home": "홈",
    "about": "소개",
    "skills": "기술",
    "projects": "프로젝트",
    "experience": "경력",
    "education": "학력",
    "contact": "연락처"
  },
  "Common": {
    "language": "EN",
    "languageLabel": "English로 전환"
  },
  "Footer": {
    "email": "이메일",
    "github": "GitHub",
    "velog": "Velog",
    "copyright": "박훈일. All rights reserved."
  },
  "Hero": {
    "name": "박훈일",
    "title": "프론트엔드 개발자",
    "intro": "깔끔하고 정교한 웹 경험을 만듭니다",
    "resumeLink": "이력서 보기"
  },
  "About": {
    "sectionTitle": "소개",
    "paragraph1": "사용자 중심의 웹 인터페이스를 설계하고 구현하는 프론트엔드 개발자입니다. React, Next.js, TypeScript를 활용한 대시보드 및 관리 시스템 개발 경험을 보유하고 있으며, 복잡한 비즈니스 로직을 직관적인 UI로 풀어내는 데 관심이 있습니다.",
    "paragraph2": "프랑스, 미얀마, 말레이시아에서의 해외 경험을 통해 다국어·다문화 환경에서의 협업 역량을 갖추었습니다. 영어(TOEIC 930)와 프랑스어 비즈니스 레벨의 언어 능력을 바탕으로 글로벌 팀과의 원활한 커뮤니케이션이 가능합니다."
  },
  "Contact": {
    "sectionTitle": "연락처",
    "description": "함께 일하고 싶으시다면 편하게 연락주세요.",
    "email": "이메일",
    "phone": "전화",
    "github": "GitHub",
    "velog": "Velog"
  },
  "Skills": {
    "sectionTitle": "기술 스택",
    "frontend": "프론트엔드",
    "backend": "백엔드",
    "devops": "DevOps",
    "database": "데이터베이스"
  },
  "Projects": {
    "sectionTitle": "프로젝트",
    "viewDetails": "자세히 보기",
    "joshua": {
      "title": "Joshua AI Agent",
      "description": "KoGPT-2 기반 카피라이팅 AI 에이전트. Electron과 Angular로 크로스플랫폼 데스크톱 앱을 구현하고 Stripe 결제를 연동했습니다.",
      "period": "2022.06 - 2023.03"
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "description": "Next.js와 NestJS 기반 고객 관리 시스템. 관리자 대시보드를 구현하고 회계 프로세스 약 90%를 자동화했습니다.",
      "period": "2024.07 - 2025.06"
    },
    "retailAnalysis": {
      "title": "리테일 매장 고객 행동 분석",
      "description": "YOLO 기반 시각지능으로 매장 내 고객 동선을 트래킹하고 VanillaJS 대시보드로 분석 결과를 시각화했습니다.",
      "period": "2022.11 - 2023.04"
    }
  },
  "Experience": {
    "sectionTitle": "경력",
    "dyCms": {
      "date": "2024.07 - 2025.06",
      "title": "DY Microfinance — 고객 관리 시스템 개발",
      "company": "DY Microfinance (미얀마)",
      "description": "Next.js, NestJS, PostgreSQL 기반 프론트엔드·백엔드 분리형 아키텍처로 고객 관리 시스템을 개발했습니다. 관리자용 대시보드를 구현하고 회계 프로세스 약 90%를 자동화했습니다."
    },
    "paymentInApp": {
      "date": "2022.05 - 2024.03",
      "title": "주식회사 페이먼트인앱 — 사업기획 총괄",
      "company": "주식회사 페이먼트인앱",
      "description": "Joshua AI Agent(Electron/Angular), 제조 불량 인식 자동화(YOLO), 리테일 매장 고객 행동 분석(VanillaJS 대시보드), EMV 서울 교통 타당성 조사 등 다수 프로젝트를 기획·총괄했습니다."
    },
    "dyAccounting": {
      "date": "2017.01 - 2018.12",
      "title": "DY Microfinance — 회계·재무 운영",
      "company": "DY Microfinance (미얀마)",
      "description": "회계·재무 운영 및 프로세스 자동화를 담당했습니다. BS·PL 자동 생성 스프레드시트를 구축하여 업무 효율을 개선했습니다."
    }
  },
  "Education": {
    "sectionTitle": "학력",
    "sangmyung": {
      "date": "2024.03 - 2026.02",
      "title": "상명대학교 빅데이터융합학과",
      "description": "졸업 예정 | GPA 4.33 / 4.5"
    },
    "yangon": {
      "date": "2017.01 - 2018.12",
      "title": "양곤외국어대학교 미얀마어과",
      "description": "중퇴"
    },
    "certificationsTitle": "자격증 · 수상",
    "certifications": {
      "computerSkills": "컴퓨터활용능력 1급 (2020.11)",
      "accounting": "전산회계 1급 (2021.03)",
      "fsi": "FSI AIxData Challenge 2024 우수상",
      "toeic": "TOEIC 930 (2025.11)"
    },
    "activitiesTitle": "활동",
    "activities": {
      "bay": "연세대학교 블록체인 학회 BAY 17기",
      "aiCourse": "영우글로벌러닝 AI S/W 전문가 양성과정 (2022.04)"
    }
  },
  "ProjectDetail": {
    "sidebar": {
      "role": "역할",
      "teamSize": "팀 규모",
      "duration": "기간",
      "techStack": "기술 스택",
      "links": "링크"
    },
    "joshua": {
      "title": "Joshua AI Agent",
      "subtitle": "KoGPT-2 기반 AI 카피라이팅 에이전트",
      "role": "프론트엔드 개발",
      "teamSize": "4명",
      "duration": "2022.06 - 2023.03",
      "overview": {
        "title": "프로젝트 개요",
        "background": "Joshua AI Agent는 KoGPT-2 언어모델을 기반으로 한 AI 카피라이팅 서비스입니다. 마케팅 콘텐츠와 광고 카피를 생성하는 유료 구독형 데스크톱 애플리케이션으로, Windows와 macOS를 모두 지원하는 크로스플랫폼 환경 구축이 필수였습니다. FastAPI 기반 백엔드와 PostgreSQL 데이터베이스를 활용한 AI 모델 서빙 아키텍처에서 프론트엔드를 담당했습니다. 주된 기술적 과제는 Electron 환경에서 Angular 프레임워크를 통합하고, AI 응답의 실시간 스트리밍 렌더링을 구현하며, Stripe 결제 플로우를 데스크톱 앱 환경에 적합하게 구성하는 것이었습니다.",
        "contribution": "프로젝트에서 프론트엔드 개발 전반을 담당했으며, Electron과 Angular를 결합한 데스크톱 애플리케이션 아키텍처 설계부터 AI 응답 인터페이스 구현, Stripe 결제 연동까지 수행했습니다. 특히 Electron의 Main 프로세스와 Renderer 프로세스 간 IPC(Inter-Process Communication) 통신 구조를 설계하여 백엔드 API와의 통신 로직을 Main 프로세스에서 처리하고, Angular 기반 Renderer 프로세스에서는 순수하게 UI 렌더링과 사용자 인터랙션에 집중할 수 있도록 관심사를 분리했습니다. AI 생성 콘텐츠의 점진적 스트리밍 표시를 위해 RxJS를 활용한 비동기 데이터 처리 파이프라인을 구축했으며, Stripe의 Checkout 세션 기반 결제 플로우를 데스크톱 환경에 맞게 커스터마이징했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "Electron + Angular 크로스플랫폼 데스크톱 앱 아키텍처",
          "problem": "일반적으로 Electron은 React나 Vue와 결합하는 경우가 많고, Angular와의 통합 사례가 상대적으로 적어 레퍼런스가 부족했습니다. Angular의 복잡한 빌드 설정(Webpack, TypeScript 컴파일러)과 Electron의 Main/Renderer 프로세스 구조를 조화롭게 구성해야 했고, 개발 환경과 프로덕션 빌드 환경 모두에서 안정적으로 작동하는 빌드 파이프라인이 필요했습니다. 특히 Angular의 개발 서버를 Electron 프로세스와 연동하는 HMR(Hot Module Replacement) 환경 구성이 핵심 과제였습니다.",
          "solution": "Electron Builder를 활용해 Angular 애플리케이션을 Electron 환경에 패키징하는 빌드 워크플로우를 구축했습니다. Main 프로세스는 순수 TypeScript로 작성하여 BrowserWindow 생성, IPC 핸들러 등록, 백엔드 API 통신 등 네이티브 기능과 시스템 레벨 로직을 담당하게 했습니다. Renderer 프로세스는 Angular CLI 기반으로 빌드된 결과물을 로드하도록 구성했으며, 개발 모드에서는 Angular dev server(localhost:4200)를 Electron이 로드하고, 프로덕션 빌드에서는 file:// 프로토콜로 dist 폴더의 정적 파일을 로드하는 방식으로 환경을 분리했습니다. IPC 통신은 ipcRenderer와 ipcMain을 사용한 request-response 패턴으로 설계해, Renderer에서 사용자 입력을 받으면 Main을 통해 백엔드 API를 호출하고, 응답을 다시 Renderer로 전달하는 단방향 데이터 흐름을 유지했습니다.",
          "result": "Windows와 macOS 양쪽에서 안정적으로 동작하는 크로스플랫폼 데스크톱 앱을 출시할 수 있었습니다. 개발 환경에서는 Angular의 HMR을 활용해 빠른 개발 사이클을 유지하면서도, 프로덕션 빌드에서는 단일 실행 파일(Windows: .exe, macOS: .dmg)로 배포할 수 있는 구조를 확립했습니다. IPC 통신 레이어 덕분에 백엔드 API 변경사항이 있어도 Main 프로세스만 수정하면 되어, Angular 컴포넌트 코드와의 결합도를 낮게 유지할 수 있었습니다."
        },
        "feature2": {
          "title": "AI 응답 실시간 스트리밍 렌더링 인터페이스",
          "problem": "KoGPT-2 모델이 생성하는 텍스트를 사용자에게 보여주는 방식이 중요했습니다. 긴 카피 문구를 한 번에 표시하면 사용자가 대기 시간 동안 아무런 피드백을 받지 못해 UX가 저하되고, 반대로 스트리밍 방식으로 토큰 단위로 점진적으로 표시하면 '생성 중'이라는 느낌을 주어 체감 속도가 빨라집니다. 백엔드에서 Server-Sent Events(SSE) 또는 청크 방식으로 응답을 보내주면, 이를 프론트엔드에서 실시간으로 받아 화면에 렌더링해야 했습니다. Angular 환경에서 비동기 스트림 데이터를 효율적으로 처리하면서 UI를 부드럽게 업데이트하는 방법이 필요했습니다.",
          "solution": "RxJS의 Observable 기반 비동기 처리 파이프라인을 구성했습니다. Electron IPC를 통해 Main 프로세스에서 백엔드 API의 스트리밍 응답을 받으면, 이를 청크 단위로 Renderer 프로세스에 이벤트로 전달하고, Angular 컴포넌트에서 Observable로 구독하여 화면에 반영했습니다. 구체적으로는 백엔드 응답을 fetch API의 ReadableStream으로 읽어들이고, 각 청크를 파싱하여 ipcRenderer.send로 Renderer에 전송하는 방식을 채택했습니다. Angular 컴포넌트에서는 fromEvent로 IPC 이벤트를 Observable화하여 scan 오퍼레이터로 누적 텍스트를 생성하고, async pipe를 통해 템플릿에 바인딩했습니다. 이를 통해 텍스트가 타이핑되는 듯한 자연스러운 애니메이션 효과를 구현했습니다.",
          "result": "사용자는 AI가 카피를 생성하는 과정을 실시간으로 볼 수 있어 대기 시간이 체감상 짧아졌고, 앱 사용 경험이 개선되었습니다. RxJS 기반 아키텍처 덕분에 에러 핸들링(catchError), 타임아웃(timeout), 재시도 로직(retry)을 선언적으로 추가할 수 있었고, 백엔드 API가 불안정해도 프론트엔드에서 안정적으로 대응할 수 있었습니다. 사용자 피드백에서도 '생성 과정이 보여서 좋다'는 긍정적인 반응을 얻었습니다."
        },
        "feature3": {
          "title": "Stripe 결제 연동 및 구독 관리 UI",
          "problem": "유료 구독 모델이었기 때문에 Stripe Checkout을 통한 결제 플로우와 구독 상태 관리 UI가 필수였습니다. 일반적인 웹 앱과 달리 데스크톱 앱 환경에서는 브라우저를 별도로 열어 결제를 진행하고, 결제 완료 후 다시 앱으로 돌아와야 하는 흐름을 구성해야 했습니다. Stripe Checkout Session을 생성하고, 외부 브라우저에서 결제를 완료한 뒤, 앱이 결제 완료 상태를 감지하여 UI를 업데이트하는 로직이 필요했습니다. 또한 사용자가 현재 구독 중인지, 무료 체험 기간인지, 결제가 실패했는지를 명확하게 보여주는 대시보드 인터페이스도 구현해야 했습니다.",
          "solution": "Stripe Checkout의 웹 기반 결제 페이지를 Electron의 shell.openExternal API를 통해 기본 브라우저에서 열도록 구성했습니다. 백엔드에서 Stripe Checkout Session을 생성하면 클라이언트는 해당 URL을 받아 브라우저를 실행하고, 사용자는 Stripe의 안전한 결제 페이지에서 카드 정보를 입력합니다. 결제 완료 후 Stripe Webhook을 통해 백엔드가 사용자 구독 상태를 업데이트하면, 앱은 주기적으로(또는 사용자가 '결제 완료' 버튼을 누르면) 백엔드 API를 polling하여 최신 구독 상태를 가져와 UI를 갱신하는 방식으로 구현했습니다. Angular 서비스 레이어에서 구독 정보를 BehaviorSubject로 관리하여 앱 전역에서 실시간으로 구독 상태를 참조할 수 있게 했고, 구독 만료일, 다음 결제일 등의 정보를 대시보드에 표시했습니다.",
          "result": "데스크톱 앱 환경에서도 안전하고 표준적인 Stripe 결제 플로우를 제공할 수 있었고, 사용자는 앱 내에서 결제 버튼을 누르면 브라우저가 열려 결제를 완료한 뒤 다시 앱으로 돌아오는 자연스러운 경험을 제공받았습니다. 구독 상태 관리 UI 덕분에 사용자는 현재 자신의 구독 플랜과 남은 기간을 명확히 인지할 수 있었고, 고객 지원 문의도 크게 줄었습니다. Stripe Webhook과 polling 방식의 조합으로 결제 완료 이벤트를 놓치지 않고 안정적으로 처리할 수 있었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "Electron IPC 통신 시 대용량 데이터 전송 오류",
          "problem": "AI가 생성한 긴 텍스트나 다량의 히스토리 데이터를 Main 프로세스에서 Renderer 프로세스로 IPC를 통해 전달할 때 간헐적으로 오류가 발생했습니다. 특정 크기 이상의 데이터를 전송하면 Electron이 메모리 부족 에러를 발생시키거나, IPC 채널이 블로킹되어 앱이 멈추는 현상이 관찰되었습니다. 초기에는 ipcRenderer.send와 ipcMain.on을 사용해 모든 데이터를 한 번에 전송하려 했으나, 데이터가 클 경우 직렬화 과정에서 병목이 발생했습니다.",
          "solution": "대용량 데이터는 청크 단위로 분할하여 여러 번 전송하는 스트리밍 방식으로 변경했습니다. ipcRenderer.invoke와 ipcMain.handle을 사용하는 Promise 기반 IPC 패턴으로 전환하고, 데이터를 일정 크기(예: 1MB) 단위로 나누어 순차적으로 전송한 뒤 Renderer에서 조립하는 로직을 구현했습니다. 또한 불필요한 데이터는 전송하지 않도록 백엔드 응답 구조를 최적화하고, 프론트엔드에서는 필요한 필드만 선택적으로 전달받는 GraphQL 스타일의 쿼리 접근 방식을 모방했습니다.",
          "result": "대용량 데이터 전송 시에도 안정적으로 동작하게 되었고, IPC 통신 병목 현상이 해소되어 앱 응답성이 크게 개선되었습니다. 사용자가 긴 히스토리를 조회하거나 다량의 카피를 일괄 생성해도 앱이 멈추지 않고 부드럽게 처리할 수 있었습니다."
        },
        "issue2": {
          "title": "Angular Zone.js와 Electron 이벤트 루프 충돌",
          "problem": "Angular는 Zone.js를 사용해 변경 감지를 자동화하는데, Electron의 IPC 이벤트가 Angular Zone 외부에서 발생하면 UI가 자동으로 업데이트되지 않는 문제가 있었습니다. 특히 ipcRenderer.on으로 등록한 이벤트 리스너에서 컴포넌트 상태를 변경해도 화면에 반영되지 않아, 사용자가 수동으로 다른 화면으로 이동했다가 돌아와야 업데이트가 보이는 상황이 발생했습니다. Zone.js의 동작 원리를 이해하지 못한 채 개발하면서 발생한 문제였습니다.",
          "solution": "NgZone 서비스를 주입하여 IPC 이벤트 핸들러 내에서 zone.run()을 명시적으로 호출해 Angular의 변경 감지 사이클에 진입하도록 수정했습니다. 모든 IPC 이벤트 수신 로직을 Angular 서비스로 캡슐화하고, fromEvent로 Observable화한 뒤 observeOn(asyncScheduler)를 사용해 Angular Zone 내에서 실행되도록 보장했습니다. 이를 통해 IPC 이벤트가 발생하면 자동으로 UI가 업데이트되도록 만들었습니다.",
          "result": "IPC 이벤트 기반 상태 변경이 즉시 화면에 반영되어 사용자 경험이 크게 개선되었습니다. Zone.js의 동작 원리를 깊이 이해하게 되었고, Electron + Angular 환경에서의 이벤트 처리 베스트 프랙티스를 확립할 수 있었습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "Electron과 Angular를 결합한 크로스플랫폼 데스크톱 애플리케이션 개발 경험을 쌓으면서, 웹 기술 스택으로 네이티브 앱을 구축하는 아키텍처에 대한 이해가 깊어졌습니다. IPC 통신 구조 설계, Main/Renderer 프로세스의 역할 분리, Angular Zone.js와 Electron 이벤트 루프의 상호작용 등 웹 프레임워크와 데스크톱 환경을 결합할 때 발생하는 특수한 문제들을 해결하며 많은 것을 배웠습니다. RxJS를 활용한 비동기 데이터 스트리밍 처리 경험은 이후 다른 프로젝트에서도 유용하게 적용할 수 있었고, Stripe 결제 통합을 통해 SaaS 비즈니스 모델의 프론트엔드 구현 역량도 확보했습니다. 특히 AI 모델 응답을 실시간 스트리밍으로 렌더링하는 인터페이스를 구현하며, 단순히 데이터를 보여주는 것을 넘어 사용자에게 '기다림'을 '경험'으로 전환하는 UX 설계의 중요성을 체감했습니다.",
        "improvement": "프로젝트 초기에 Electron과 Angular의 통합 방식에 대한 레퍼런스가 부족해 많은 시행착오를 겪었습니다. 미리 충분한 기술 검증(POC)을 수행하고 아키텍처를 확정했다면 개발 속도를 높일 수 있었을 것입니다. 또한 IPC 통신 레이어에 대한 테스트 코드가 부족해 디버깅에 많은 시간을 소비했는데, Main 프로세스와 Renderer 프로세스 간 통신 로직에 대한 단위 테스트와 통합 테스트를 체계적으로 작성했다면 안정성을 더 높일 수 있었을 것입니다. 성능 최적화 측면에서도 번들 사이즈 최적화(Tree-shaking, Lazy Loading)와 메모리 프로파일링을 더 철저히 수행했다면 앱 실행 속도와 리소스 사용량을 개선할 수 있었을 것으로 생각합니다. 향후 유사한 프로젝트에서는 초기 설계 단계에서 테스트 전략과 성능 목표를 명확히 수립하고, 지속적인 모니터링과 개선을 병행할 계획입니다."
      }
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "subtitle": "고객 관리 시스템",
      "role": "풀스택 개발",
      "teamSize": "1명 (솔로)",
      "duration": "2024.07 - 2025.06",
      "overview": {
        "title": "프로젝트 개요",
        "background": "DY Microfinance CMS는 미얀마 소재 소액금융기관의 고객 관리 및 회계 업무를 자동화하기 위한 웹 기반 관리 시스템입니다. 기존에는 Excel 스프레드시트와 수작업으로 고객 정보, 대출 내역, 회계 장부를 관리하다 보니 데이터 정합성 문제가 빈번했고, 월말 결산 시 수십 시간의 수작업이 필요했습니다. 이를 해결하기 위해 Next.js 기반 프론트엔드와 NestJS 기반 백엔드를 PostgreSQL 데이터베이스로 연결한 분리형 아키텍처를 채택했습니다. 1인 개발자로서 프론트엔드와 백엔드를 모두 담당했으며, 프론트엔드에서는 관리자용 대시보드 UI/UX 설계와 구현, 복잡한 회계 데이터 테이블 관리, 폼 검증 로직 등을 중점적으로 다뤘습니다.",
        "contribution": "전체 시스템 아키텍처 설계부터 배포까지 모든 과정을 담당했으며, 프론트엔드 관점에서는 Next.js App Router 기반의 관리자 대시보드, Server Actions를 활용한 폼 처리, 회계 데이터 테이블 렌더링 최적화, 다국어(미얀마어/영어) 지원 등을 구현했습니다. 대시보드에서는 고객 수, 대출 잔액, 월별 수익 등의 핵심 지표를 실시간으로 시각화하여 경영진이 한눈에 현황을 파악할 수 있도록 했습니다. 회계 프로세스 자동화를 통해 BS(대차대조표)와 PL(손익계산서)을 자동 생성하는 인터페이스를 구축했고, 이를 통해 약 90%의 수작업을 제거하여 월말 결산 시간을 수십 시간에서 수 시간으로 단축했습니다. 또한 사용자(대출 상담사, 회계 담당자, 관리자)별로 권한을 구분하여 각자 필요한 화면과 기능만 접근할 수 있도록 Role-Based Access Control을 프론트엔드 라우팅 레벨에서 구현했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "Next.js 기반 관리자 대시보드 설계 및 구현",
          "problem": "회계 담당자와 관리자가 매일 확인해야 하는 정보가 많았습니다. 고객 수, 대출 잔액, 연체율, 월별 수익, 최근 대출 신청 내역 등 다양한 데이터를 한 화면에서 직관적으로 보여줘야 했고, 데이터가 실시간으로 업데이트되면서도 페이지 로딩 속도가 느려지지 않아야 했습니다. 특히 PostgreSQL에서 집계 쿼리를 수행할 때 시간이 오래 걸리는 경우가 있어, 프론트엔드에서 어떻게 데이터를 가져와 표시할지 전략이 필요했습니다. 또한 미얀마 현지 사용자들의 인터넷 환경이 불안정한 점을 고려하여 오프라인 대응과 데이터 캐싱도 중요한 요구사항이었습니다.",
          "solution": "Next.js App Router의 Server Components를 활용해 대시보드 초기 렌더링 시 서버에서 데이터를 미리 가져와 HTML에 포함시켜 전송하는 방식으로 초기 로딩 속도를 최적화했습니다. 핵심 지표(고객 수, 대출 잔액 등)는 백엔드 API에서 미리 계산된 값을 제공받아 프론트엔드에서는 단순히 표시만 하도록 했고, 복잡한 집계는 PostgreSQL의 Materialized View를 활용해 백엔드에서 주기적으로 갱신하도록 구성했습니다. 차트 렌더링에는 Recharts 라이브러리를 사용해 월별 수익 추이, 대출 상환율 등을 시각화했고, 테이블 컴포넌트는 TanStack Table을 활용해 정렬, 필터링, 페이지네이션 기능을 클라이언트 사이드에서 빠르게 처리할 수 있도록 했습니다. 또한 React Query(TanStack Query)를 도입하여 API 응답을 캐싱하고, stale-while-revalidate 전략으로 사용자가 대시보드를 재방문할 때 캐시된 데이터를 먼저 보여주고 백그라운드에서 최신 데이터를 가져오도록 구성했습니다.",
          "result": "관리자 대시보드 초기 로딩 시간이 3초 이하로 단축되었고, 사용자는 페이지를 열자마자 핵심 지표를 즉시 확인할 수 있게 되었습니다. React Query의 캐싱 덕분에 사용자가 대시보드를 자주 방문해도 불필요한 API 호출이 줄어들어 서버 부하도 감소했습니다. 차트와 테이블이 부드럽게 렌더링되어 사용자 만족도가 높아졌고, 인터넷이 불안정한 환경에서도 캐시된 데이터로 기본적인 정보 확인이 가능해졌습니다."
        },
        "feature2": {
          "title": "프론트엔드-백엔드 분리형 아키텍처와 API 연동",
          "problem": "초기에는 Next.js의 API Routes를 사용해 풀스택 구성으로 개발할지, 아니면 프론트엔드와 백엔드를 완전히 분리할지 고민이었습니다. 향후 모바일 앱이나 다른 클라이언트가 추가될 가능성을 고려하면 백엔드를 독립적인 API 서버로 분리하는 것이 유리했지만, 1인 개발 환경에서 두 개의 프로젝트를 관리하는 부담도 컸습니다. 또한 프론트엔드에서 백엔드 API를 호출할 때 타입 안정성을 유지하고, 인증 토큰 관리, 에러 핸들링 등을 일관되게 처리하는 아키텍처가 필요했습니다.",
          "solution": "Next.js 프론트엔드와 NestJS 백엔드를 분리하되, 개발 환경에서는 Next.js의 rewrites 기능을 활용해 /api/* 경로를 NestJS 서버로 프록시하여 CORS 이슈를 회피했습니다. 프로덕션 환경에서는 Nginx를 리버스 프록시로 사용해 프론트엔드와 백엔드를 동일 도메인에서 서비스하도록 구성했습니다. API 클라이언트는 axios 기반 커스텀 인스턴스를 만들어, 모든 요청에 JWT 토큰을 자동으로 포함시키고, 401 응답 시 자동으로 토큰 갱신을 시도하는 인터셉터를 구현했습니다. 타입 안정성을 위해 백엔드 NestJS에서 정의한 DTO(Data Transfer Object)를 프론트엔드에서 공유하여, TypeScript 타입 추론을 통해 API 요청/응답 구조를 컴파일 타임에 검증할 수 있도록 했습니다. Zod를 사용해 런타임 타입 검증도 추가하여 백엔드 응답이 예상과 다를 경우 즉시 에러를 발생시켜 디버깅을 용이하게 했습니다.",
          "result": "프론트엔드와 백엔드가 명확히 분리되어, 각각의 개발과 배포가 독립적으로 가능해졌습니다. NestJS 백엔드는 RESTful API 서버로 기능하여 향후 모바일 앱이나 외부 시스템과의 연동이 용이한 구조가 되었고, Next.js 프론트엔드는 순수하게 UI/UX에 집중할 수 있었습니다. 타입 공유 구조 덕분에 백엔드 API 변경 시 프론트엔드에서 타입 에러가 즉시 발생하여, 런타임 에러를 사전에 방지할 수 있었습니다. axios 인터셉터를 통한 자동 토큰 갱신 로직으로 사용자가 장시간 대시보드를 사용해도 세션이 끊기지 않아 사용자 경험이 개선되었습니다."
        },
        "feature3": {
          "title": "회계 프로세스 자동화 인터페이스 구현",
          "problem": "기존 회계 프로세스는 대출 내역, 상환 내역, 비용 지출 등의 데이터를 수작업으로 Excel에 입력하고, 월말에 BS와 PL을 수동으로 작성하는 방식이었습니다. 이를 자동화하려면 프론트엔드에서 대출/상환/지출 데이터를 입력받는 폼을 제공하고, 백엔드에서 회계 로직을 수행한 뒤, 결과를 프론트엔드에서 보고서 형태로 출력해야 했습니다. 특히 회계 데이터의 정합성이 중요했기 때문에, 입력 단계에서 엄격한 검증이 필요했고, 사용자가 실수로 잘못된 데이터를 입력하지 않도록 UX 차원에서 가이드를 제공해야 했습니다. 또한 월말 보고서는 PDF로 출력할 수 있어야 했습니다.",
          "solution": "Next.js의 Server Actions를 활용해 폼 제출 시 서버 사이드에서 데이터 검증과 DB 저장을 처리하도록 구성했습니다. 클라이언트 사이드에서는 React Hook Form과 Zod를 조합하여 실시간 폼 검증을 수행하고, 사용자가 필드를 입력할 때마다 즉각적인 피드백(에러 메시지, 성공 인디케이터)을 제공했습니다. 예를 들어 대출 금액 입력 시 숫자만 허용하고, 상환일은 대출일보다 미래여야 한다는 조건을 클라이언트와 서버 양쪽에서 검증했습니다. 월말 보고서 생성 기능은 사용자가 '보고서 생성' 버튼을 누르면 백엔드에서 회계 데이터를 집계하여 BS/PL을 생성하고, 프론트엔드에서는 이를 테이블 형태로 렌더링한 뒤, React-PDF 라이브러리를 사용해 클라이언트 사이드에서 PDF로 변환하여 다운로드할 수 있도록 구현했습니다. 이를 통해 월말 결산 프로세스를 '데이터 입력 → 버튼 클릭 → 보고서 다운로드'의 3단계로 단순화했습니다.",
          "result": "회계 프로세스 자동화로 월말 결산 시간이 기존 수십 시간에서 수 시간으로 단축되었고, 수작업으로 인한 오류(오타, 계산 실수 등)가 거의 사라졌습니다. 사용자는 폼 입력 시 실시간으로 에러 피드백을 받아 잘못된 데이터를 미리 수정할 수 있었고, 보고서를 PDF로 즉시 출력하여 경영진에게 제출할 수 있어 업무 효율이 크게 향상되었습니다. 자동화율 약 90%를 달성하여 회계 담당자의 업무 부담이 대폭 줄어들었고, 데이터 정합성도 크게 개선되었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "대시보드 테이블 렌더링 성능 저하",
          "problem": "고객 수가 수천 명으로 늘어나면서 대시보드의 고객 목록 테이블을 렌더링할 때 브라우저가 버벅이는 현상이 발생했습니다. 초기에는 백엔드에서 전체 고객 데이터를 한 번에 가져와 프론트엔드에서 렌더링했는데, 수천 개의 행을 DOM에 그리다 보니 렌더링 시간이 수 초 걸렸고, 스크롤 시에도 버벅임이 심했습니다. 사용자는 테이블을 빠르게 스크롤하며 특정 고객을 찾고 싶어 했지만, 렌더링 성능 문제로 사용성이 크게 저하되었습니다.",
          "solution": "가상 스크롤링(Virtual Scrolling) 기법을 도입하여 현재 뷰포트에 보이는 행만 DOM에 렌더링하도록 최적화했습니다. TanStack Table의 가상화 기능을 활용해, 수천 개의 데이터가 있어도 실제로는 화면에 보이는 20-30개의 행만 렌더링하고, 스크롤 시 동적으로 DOM을 교체하는 방식으로 변경했습니다. 또한 서버 사이드 페이지네이션을 추가 옵션으로 제공하여, 사용자가 페이지당 50개씩 데이터를 가져오도록 선택할 수 있게 했습니다. 검색 필터 기능도 강화하여 사용자가 이름이나 대출 ID로 필터링하면 해당하는 데이터만 백엔드에서 가져와 렌더링하도록 구성했습니다.",
          "result": "테이블 렌더링 성능이 극적으로 개선되어, 수천 개의 고객 데이터가 있어도 초기 로딩이 1초 이내로 완료되고, 스크롤이 부드럽게 동작하게 되었습니다. 사용자는 빠르게 데이터를 탐색할 수 있었고, 가상 스크롤링 덕분에 메모리 사용량도 크게 줄어들어 저사양 환경에서도 안정적으로 동작했습니다."
        },
        "issue2": {
          "title": "폼 제출 시 중복 요청 방지",
          "problem": "사용자가 대출 신청 폼을 제출할 때 버튼을 여러 번 클릭하거나, 네트워크가 느려서 응답이 늦어지면 같은 데이터가 중복으로 DB에 저장되는 문제가 발생했습니다. 특히 미얀마 현지의 불안정한 인터넷 환경에서는 사용자가 '제출' 버튼을 누른 후 아무 반응이 없어 다시 누르는 경우가 빈번했습니다. 이로 인해 동일한 대출 신청이 두 번 생성되는 등의 데이터 정합성 문제가 발생했습니다.",
          "solution": "프론트엔드에서 폼 제출 시 버튼을 즉시 비활성화(disabled)하고, 로딩 인디케이터(스피너)를 표시하여 사용자에게 '처리 중'임을 명확히 알렸습니다. React Hook Form의 isSubmitting 상태를 활용해 제출 중에는 버튼을 클릭할 수 없도록 막았고, Server Action이 완료되면 성공 메시지를 표시하거나 에러 메시지를 보여주는 피드백을 추가했습니다. 백엔드에서도 멱등성(Idempotency) 처리를 추가하여, 동일한 요청이 짧은 시간 내에 여러 번 들어오면 첫 번째 요청만 처리하고 나머지는 무시하도록 Redis 기반 중복 요청 체크 로직을 구현했습니다. 또한 Optimistic UI 패턴을 적용하여 폼 제출 즉시 UI를 업데이트하고, 백엔드 응답을 기다린 뒤 확정하는 방식으로 사용자 경험을 개선했습니다.",
          "result": "중복 요청으로 인한 데이터 정합성 문제가 완전히 해결되었고, 사용자는 폼 제출 후 즉시 피드백을 받아 '처리 중'임을 명확히 인지할 수 있었습니다. 네트워크가 느린 환경에서도 사용자가 여러 번 버튼을 누르지 않게 되어, 불필요한 요청이 줄어들었고 서버 부하도 감소했습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "1인 풀스택 개발자로서 프론트엔드와 백엔드를 모두 설계하고 구현하면서 웹 애플리케이션의 전체 아키텍처에 대한 이해가 깊어졌습니다. 특히 Next.js의 App Router, Server Components, Server Actions 등 최신 기능을 실전에서 활용하며 SSR과 CSR의 장단점을 체감했고, 어떤 상황에서 어떤 렌더링 전략을 선택해야 하는지 판단할 수 있게 되었습니다. 프론트엔드-백엔드 분리형 아키텍처를 구성하며 API 설계, 타입 안정성 확보, 인증/인가 처리 등 실무에서 필수적인 역량을 쌓았습니다. 또한 대시보드와 데이터 시각화 UI를 구현하며 복잡한 비즈니스 로직을 사용자 친화적인 인터페이스로 풀어내는 UX 설계 능력을 향상시켰습니다. 특히 회계 프로세스 자동화를 통해 단순히 '기능 구현'을 넘어 '비즈니스 임팩트'를 만들어내는 개발의 가치를 체감했고, 사용자 피드백을 반영하여 지속적으로 개선하는 과정에서 큰 보람을 느꼈습니다.",
        "improvement": "프로젝트 초기에 테스트 코드 작성을 미루다 보니, 기능 추가 시 기존 기능이 깨지는 리그레션 이슈가 종종 발생했습니다. 특히 회계 로직처럼 정확성이 중요한 부분에서는 단위 테스트와 통합 테스트가 필수적인데, 일정에 쫓겨 생략한 것이 아쉬웠습니다. 향후에는 TDD(Test-Driven Development) 또는 최소한 핵심 비즈니스 로직에 대한 테스트 커버리지를 확보하는 습관을 들이고 싶습니다. 또한 CI/CD 파이프라인 구축도 미흡했습니다. 수동으로 서버에 SSH 접속하여 배포하는 방식이었는데, GitHub Actions 등을 활용한 자동화된 배포 파이프라인을 구축했다면 배포 속도와 안정성을 높일 수 있었을 것입니다. 성능 모니터링 측면에서도 Sentry나 LogRocket 같은 툴을 도입해 프로덕션 환경에서 발생하는 에러와 성능 병목을 실시간으로 추적했다면 더 빠르게 문제를 해결할 수 있었을 것입니다. 다음 프로젝트에서는 테스트, CI/CD, 모니터링을 초기부터 계획하여 보다 안정적이고 유지보수 가능한 시스템을 구축할 계획입니다."
      }
    },
    "retailAnalysis": {
      "title": "리테일 매장 고객 행동 분석",
      "subtitle": "시각지능 기반 고객 동선 분석 시스템",
      "role": "데이터 시각화 개발",
      "teamSize": "3명",
      "duration": "2022.11 - 2023.04",
      "overview": {
        "title": "프로젝트 개요",
        "background": "말레이시아 소재 리테일 매장에서 YOLO 객체 인식 모델을 활용해 매장 내 고객의 동선을 실시간으로 추적하고 분석하는 시스템입니다. CCTV 영상에서 고객의 위치와 이동 경로를 인식하여, 어느 진열대에서 얼마나 머물렀는지, 어떤 동선으로 매장을 이동했는지 등의 데이터를 수집합니다. 이를 통해 매장 관리자는 고객의 행동 패턴을 이해하고, 진열 위치 최적화나 동선 개선 등의 인사이트를 얻을 수 있습니다. 백엔드에서는 PyTorch로 구현된 YOLO 모델이 실시간 영상 처리를 수행하고, 프론트엔드에서는 이 데이터를 받아 대시보드 형태로 시각화하는 역할을 담당했습니다. 프론트엔드 기술 스택으로는 의도적으로 VanillaJS(순수 JavaScript)를 선택했는데, 이는 React나 Vue 같은 프레임워크 없이도 복잡한 실시간 데이터 시각화를 구현할 수 있는지 검증하고, 번들 사이즈와 성능을 최적화하기 위함이었습니다.",
        "contribution": "프로젝트에서 프론트엔드 데이터 시각화 전반을 담당했으며, VanillaJS로 실시간 대시보드를 구축했습니다. 백엔드 팀이 WebSocket을 통해 전송하는 고객 위치 데이터를 받아, Canvas API와 SVG를 활용한 히트맵과 동선 트래킹 시각화를 구현했습니다. 매장 평면도 위에 고객의 현재 위치를 실시간으로 표시하고, 시간대별 고객 밀집도를 색상 그라데이션으로 나타내는 히트맵을 그렸으며, 개별 고객의 이동 경로를 선으로 연결하여 동선을 추적할 수 있도록 했습니다. 또한 통계 차트(시간대별 방문자 수, 구역별 체류 시간 등)를 Chart.js 라이브러리를 활용해 구현했습니다. 프레임워크 없이 상태 관리와 DOM 조작을 수행해야 했기 때문에, 간단한 상태 관리 패턴(Observer 패턴)과 컴포넌트 분리 구조를 직접 설계했습니다. 실시간으로 들어오는 데이터를 효율적으로 처리하기 위해 렌더링 최적화(RequestAnimationFrame, Debouncing)를 적용했고, 메모리 누수를 방지하기 위한 이벤트 리스너 정리 로직도 구현했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "VanillaJS 기반 실시간 데이터 시각화 대시보드",
          "problem": "React나 Vue 같은 프레임워크 없이 복잡한 실시간 대시보드를 구현해야 했습니다. 프레임워크가 제공하는 컴포넌트 구조, 상태 관리, 가상 DOM 등의 편의 기능 없이, 순수 JavaScript로 WebSocket 데이터를 받아 Canvas와 SVG에 실시간으로 렌더링하고, 사용자 인터랙션(줌, 팬, 시간대 필터링 등)을 처리해야 했습니다. 특히 초당 수십 개의 위치 데이터가 들어올 때 DOM을 직접 조작하면 성능 저하가 발생할 수 있어, 효율적인 렌더링 전략이 필요했습니다. 또한 코드 구조가 스파게티 코드로 변질되지 않도록 모듈화와 관심사 분리를 고민해야 했습니다.",
          "solution": "ES6 Modules를 활용해 코드를 기능별로 모듈화했습니다. WebSocket 통신을 담당하는 DataService 모듈, Canvas 렌더링을 담당하는 HeatmapRenderer 모듈, SVG 동선 렌더링을 담당하는 PathRenderer 모듈, 차트 렌더링을 담당하는 ChartRenderer 모듈 등으로 분리했습니다. 상태 관리는 간단한 Observer 패턴을 구현하여, DataService가 새로운 데이터를 받으면 등록된 렌더러들에게 알림(notify)을 보내 각자 업데이트하도록 했습니다. Canvas 렌더링은 requestAnimationFrame을 활용해 브라우저의 리페인트 주기에 맞춰 렌더링하여 부드러운 애니메이션을 구현했고, 불필요한 렌더링을 줄이기 위해 데이터가 변경되었을 때만 다시 그리도록 조건을 설정했습니다. 히트맵은 2D 배열에 고객 체류 시간을 누적하고, 이를 색상 그라데이션으로 변환하여 Canvas에 그리는 방식으로 구현했습니다. SVG는 각 고객의 이동 경로를 path 엘리먼트로 표현하여 동적으로 추가/제거했습니다. 사용자 인터랙션(드래그로 화면 이동, 마우스 휠로 줌)은 이벤트 리스너를 등록하여 Canvas transform을 조작하는 방식으로 처리했습니다.",
          "result": "프레임워크 없이도 안정적이고 성능이 우수한 실시간 대시보드를 구현할 수 있었습니다. 번들 사이즈가 작아(Chart.js 제외 시 100KB 미만) 초기 로딩이 매우 빨랐고, Canvas 기반 렌더링 덕분에 수백 개의 데이터 포인트를 동시에 표시해도 60fps를 유지할 수 있었습니다. 모듈화된 코드 구조 덕분에 새로운 시각화 기능(예: 특정 구역 클릭 시 상세 정보 표시)을 추가할 때도 다른 모듈에 영향을 주지 않고 독립적으로 개발할 수 있었습니다. 매장 관리자는 대시보드를 통해 실시간으로 고객 동선을 모니터링하고, 시간대별 패턴을 분석하여 매장 레이아웃 개선에 활용할 수 있었습니다."
        },
        "feature2": {
          "title": "Canvas 기반 고객 동선 히트맵 및 트래킹 UI",
          "problem": "매장 평면도 위에 고객의 동선을 직관적으로 표현해야 했습니다. 수십 명의 고객이 동시에 이동하는 상황에서 각 고객의 위치와 이동 경로를 실시간으로 표시하면서도, 전체적인 패턴(어느 구역이 인기 있는지, 어떤 동선이 많은지)을 한눈에 파악할 수 있는 시각화가 필요했습니다. 히트맵은 시간이 지남에 따라 누적되는 데이터를 색상으로 표현해야 하고, 동선 트래킹은 개별 고객의 경로를 선으로 연결하여 보여줘야 했습니다. 또한 사용자가 시간대를 선택하면 해당 시간대의 데이터만 필터링하여 보여주는 기능도 필요했습니다.",
          "solution": "Canvas API를 활용해 매장 평면도를 배경으로 그리고, 그 위에 히트맵 레이어와 동선 레이어를 오버레이하는 방식으로 구현했습니다. 히트맵은 매장을 그리드로 나누고(예: 1m x 1m), 각 그리드 셀에 고객이 머문 시간을 누적한 뒤, 값의 크기에 따라 파란색(낮음) → 초록색(중간) → 빨간색(높음) 그라데이션으로 표현했습니다. Canvas의 fillRect와 createLinearGradient를 활용해 부드러운 색상 전환을 구현했습니다. 동선 트래킹은 각 고객의 이동 경로를 배열에 저장하고, Canvas의 lineTo와 stroke를 사용해 경로를 선으로 그렸습니다. 시간대 필터링은 사용자가 슬라이더를 조작하면 해당 시간 범위의 데이터만 필터링하여 히트맵과 동선을 다시 렌더링하도록 구현했습니다. 데이터가 많을 때 성능을 위해, 전체 데이터를 미리 계산하여 캐싱하고, 필터링 시에는 캐시된 데이터를 참조하여 빠르게 렌더링했습니다. 또한 고객이 특정 구역을 클릭하면 해당 구역의 상세 통계(평균 체류 시간, 방문 고객 수 등)를 툴팁으로 표시하는 인터랙션도 추가했습니다.",
          "result": "매장 관리자는 히트맵을 통해 '어느 진열대가 가장 인기 있는지', '고객이 잘 가지 않는 사각지대는 어디인지'를 시각적으로 파악할 수 있었습니다. 동선 트래킹을 통해 '입구에서 들어온 고객이 주로 어떤 경로로 이동하는지', '계산대까지 가는 동선이 효율적인지' 등을 분석할 수 있었습니다. 시간대 필터링 기능 덕분에 평일 오전, 주말 저녁 등 시간대별 패턴 차이를 비교할 수 있었고, 이를 바탕으로 진열 위치나 프로모션 전략을 조정하는 데 활용되었습니다. Canvas 기반 렌더링으로 수백 개의 경로를 동시에 표시해도 성능 저하 없이 부드럽게 동작했습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "실시간 데이터 렌더링 시 메모리 누수",
          "problem": "대시보드를 장시간 실행하면 브라우저의 메모리 사용량이 계속 증가하여 결국 브라우저가 느려지거나 크래시되는 문제가 발생했습니다. 초기에는 WebSocket으로 들어오는 데이터를 계속 배열에 누적하고, Canvas를 렌더링할 때마다 전체 데이터를 순회하며 그렸는데, 시간이 지날수록 배열 크기가 커져 렌더링 속도가 느려지고 메모리를 과도하게 사용하게 되었습니다. 또한 이벤트 리스너를 제대로 정리하지 않아 메모리 누수가 발생했습니다.",
          "solution": "데이터 보관 전략을 수정하여, 일정 시간(예: 1시간) 이상 지난 데이터는 자동으로 삭제하도록 했습니다. 순환 버퍼(Circular Buffer) 패턴을 적용해 최대 데이터 크기를 제한하고, 새로운 데이터가 들어오면 가장 오래된 데이터를 제거하는 방식으로 변경했습니다. 렌더링 최적화를 위해 전체 데이터를 매번 그리지 않고, 변경된 부분만 다시 그리는 부분 업데이트 방식을 도입했습니다. 이벤트 리스너는 컴포넌트가 제거될 때(페이지 이동 시) removeEventListener를 호출하여 명시적으로 정리했습니다. WebSocket 연결도 페이지를 벗어날 때 close()를 호출하여 연결을 종료했습니다. 또한 Chrome DevTools의 Performance Monitor와 Memory Profiler를 활용해 메모리 누수 지점을 찾아 수정했습니다.",
          "result": "메모리 누수가 해결되어 대시보드를 하루 종일 실행해도 브라우저가 안정적으로 동작하게 되었습니다. 메모리 사용량이 일정 수준 이하로 유지되었고, 렌더링 성능도 개선되어 장시간 사용해도 부드러운 애니메이션을 유지할 수 있었습니다. 매장 관리자는 대시보드를 계속 켜두고 실시간으로 모니터링할 수 있게 되었습니다."
        },
        "issue2": {
          "title": "VanillaJS 환경에서 상태 관리 복잡도 증가",
          "problem": "프레임워크 없이 순수 JavaScript로 개발하다 보니, 상태 관리가 점점 복잡해졌습니다. 여러 모듈이 동일한 데이터를 참조하고 수정하면서 데이터 동기화 문제가 발생했고, 어떤 모듈이 데이터를 변경했는지 추적하기 어려워 디버깅이 힘들었습니다. 특히 사용자가 필터를 변경하면 여러 차트와 히트맵을 동시에 업데이트해야 했는데, 각 모듈을 수동으로 호출하다 보니 코드가 복잡해지고 에러가 발생하기 쉬웠습니다.",
          "solution": "간단한 상태 관리 라이브러리를 직접 구현했습니다. Observer 패턴을 기반으로 중앙 Store 객체를 만들고, 각 모듈(렌더러, 차트 등)은 Store를 구독(subscribe)하여 데이터가 변경되면 자동으로 알림을 받도록 했습니다. Store는 상태를 불변(immutable) 방식으로 관리하여, 상태 변경 시 새로운 객체를 반환하고, 이전 상태와 비교하여 실제로 변경된 부분만 렌더링하도록 최적화했습니다. 상태 변경 로직은 Actions 객체에 정의하여, 모든 상태 변경이 명시적인 액션을 통해 이루어지도록 구조화했습니다. 이를 통해 Redux와 유사한 단방향 데이터 흐름을 VanillaJS 환경에서 구현했습니다. 디버깅을 위해 상태 변경 이력을 콘솔에 로깅하는 미들웨어도 추가했습니다.",
          "result": "상태 관리가 명확해지고 예측 가능해졌습니다. 데이터 변경이 발생하면 구독 중인 모든 모듈이 자동으로 업데이트되어, 수동으로 각 모듈을 호출할 필요가 없어졌습니다. 버그 발생 시 상태 변경 이력을 추적하여 원인을 빠르게 파악할 수 있었고, 새로운 기능 추가 시에도 기존 코드를 수정하지 않고 새로운 모듈을 구독시키기만 하면 되어 유지보수성이 크게 향상되었습니다. VanillaJS로도 충분히 복잡한 상태 관리가 가능하다는 것을 증명했지만, 동시에 React나 Vue 같은 프레임워크가 제공하는 가치(컴포넌트 구조, 가상 DOM, 개발자 도구 등)를 더욱 체감하게 되었습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "프레임워크 없이 VanillaJS로 복잡한 실시간 대시보드를 구현하면서, JavaScript의 근본적인 동작 원리와 브라우저 렌더링 메커니즘에 대한 이해가 깊어졌습니다. Canvas API와 SVG를 직접 다루며 저수준 그래픽 렌더링 경험을 쌓았고, WebSocket을 통한 실시간 데이터 처리와 메모리 관리, 성능 최적화 등 실무 프론트엔드 개발에서 중요한 역량을 강화했습니다. 특히 상태 관리 패턴을 직접 설계하고 구현하면서, React나 Vue에서 제공하는 상태 관리 라이브러리가 내부적으로 어떻게 동작하는지 이해할 수 있었고, 이후 Redux나 Vuex를 사용할 때 더 깊이 있는 활용이 가능해졌습니다. 메모리 누수와 렌더링 성능 문제를 해결하며 Chrome DevTools를 활용한 프로파일링 기법을 익혔고, requestAnimationFrame, Debouncing, Observer 패턴 등 실무에서 자주 쓰이는 최적화 패턴을 실전에서 적용해보는 귀중한 경험을 했습니다. Canvas 기반 데이터 시각화를 통해 대용량 데이터를 효율적으로 표현하는 방법을 배웠고, 이는 이후 다른 프로젝트에서 차트나 그래프를 구현할 때 큰 도움이 되었습니다.",
        "improvement": "VanillaJS로 개발하면서 프레임워크의 필요성을 절감했습니다. 컴포넌트 재사용성, 선언적 UI, 가상 DOM 등 모던 프레임워크가 제공하는 편의 기능 없이 모든 것을 수동으로 구현하다 보니 개발 속도가 느리고 코드 중복이 많았습니다. 특히 여러 모듈 간 데이터 동기화나 DOM 업데이트 로직을 수동으로 관리하는 것이 번거로웠고, 실수로 인한 버그가 자주 발생했습니다. 만약 React를 사용했다면 상태 관리는 useState나 useReducer로 간단히 처리하고, Canvas 렌더링은 useEffect로 관리하여 코드를 훨씬 간결하게 작성할 수 있었을 것입니다. 또한 컴포넌트 기반 구조로 차트, 히트맵, 동선 등을 독립적인 컴포넌트로 분리하여 재사용성과 테스트 용이성을 높일 수 있었을 것입니다. 프로젝트 후반부에는 '이 정도 규모라면 React를 쓰는 게 맞았다'는 생각이 들었고, VanillaJS는 작은 규모의 인터랙티브 요소나 레거시 시스템 유지보수에는 적합하지만, 복잡한 SPA를 구축하기에는 한계가 있다는 것을 체감했습니다. 향후 유사한 프로젝트에서는 기술 선택 단계에서 프로젝트 규모와 복잡도를 고려하여, 적절한 프레임워크를 선택하는 것이 중요하다는 교훈을 얻었습니다. 다음에는 React + D3.js 조합으로 더 나은 구조의 데이터 시각화 대시보드를 구축해보고 싶습니다."
      }
    }
  }
}
