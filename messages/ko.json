{
  "Home": {
    "title": "박훈일",
    "subtitle": "프론트엔드 개발자",
    "description": "깔끔하고 정교한 웹 경험을 만듭니다",
    "comingSoon": "더 많은 섹션이 곧 추가됩니다"
  },
  "Navigation": {
    "home": "홈",
    "about": "소개",
    "skills": "기술",
    "projects": "프로젝트",
    "experience": "경력",
    "education": "학력",
    "contact": "연락처",
    "lab": "Lab"
  },
  "Common": {
    "language": "EN",
    "languageLabel": "English로 전환"
  },
  "Lab": {
    "backToHome": "홈으로",
    "loading": "로딩 중...",
    "scrollHint": "오브젝트를 클릭하여 둘러보기"
  },
  "Footer": {
    "email": "이메일",
    "github": "GitHub",
    "velog": "Velog",
    "copyright": "박훈일. All rights reserved."
  },
  "Hero": {
    "name": "박훈일",
    "title": "프론트엔드 개발자",
    "intro": "깔끔하고 정교한 웹 경험을 만듭니다",
    "resumeLink": "이력서 보기"
  },
  "About": {
    "sectionTitle": "소개",
    "paragraph1": "사용자 중심의 웹 인터페이스를 설계하고 구현하는 프론트엔드 개발자입니다. React, Next.js, TypeScript를 활용한 대시보드 및 관리 시스템 개발 경험을 보유하고 있으며, 복잡한 비즈니스 로직을 직관적인 UI로 풀어내는 데 관심이 있습니다.",
    "paragraph2": "프랑스, 미얀마, 말레이시아에서의 해외 경험을 통해 다국어·다문화 환경에서의 협업 역량을 갖추었습니다. 영어(TOEIC 930)와 프랑스어 비즈니스 레벨의 언어 능력을 바탕으로 글로벌 팀과의 원활한 커뮤니케이션이 가능합니다."
  },
  "Contact": {
    "sectionTitle": "연락처",
    "email": "이메일",
    "phone": "전화",
    "github": "GitHub",
    "velog": "Velog"
  },
  "Skills": {
    "sectionTitle": "기술 스택",
    "frontend": "프론트엔드",
    "backend": "백엔드",
    "devops": "DevOps",
    "database": "데이터베이스"
  },
  "Projects": {
    "sectionTitle": "프로젝트",
    "viewDetails": "자세히 보기",
    "joshua": {
      "title": "Joshua AI Agent",
      "description": "KoGPT-2 기반 카피라이팅 AI 에이전트. Electron과 Angular로 크로스플랫폼 데스크톱 앱을 구현하고 Stripe 결제를 연동했습니다.",
      "period": "2022.06 - 2023.03"
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "description": "Next.js와 NestJS 기반 고객 관리 시스템. 관리자 대시보드를 구현하고 회계 프로세스 약 90%를 자동화했습니다.",
      "period": "2024.07 - 2025.06"
    },
    "retailAnalysis": {
      "title": "리테일 매장 고객 행동 분석",
      "description": "YOLO 기반 시각지능으로 매장 내 고객 동선을 트래킹하고 VanillaJS 대시보드로 분석 결과를 시각화했습니다.",
      "period": "2022.11 - 2023.04"
    },
    "scholarlyChain": {
      "title": "Scholarly Chain",
      "description": "Hyperledger Fabric 블록체인 기반 학생회비 투명 관리 시스템. Next.js와 shadcn/ui로 15+ 페이지를 구현하고 역할 기반 UI와 FCM 푸시 알림을 연동했습니다.",
      "period": "2025.03 - 2025.06"
    },
    "dinoGo": {
      "title": "Dino Go",
      "description": "Sui 블록체인 위치 기반 NFT 수집 게임. Next.js와 Three.js로 3D 맵을 구현하고 Walrus 분산 스토리지와 Seal 암호화를 연동했습니다.",
      "period": "2025.09.19 - 2025.09.21"
    },
    "artWar": {
      "title": "Ministry of Truth",
      "description": "AI 에이전트들이 자율적으로 참여하는 그림 경연 토너먼트 플랫폼. OpenClaw 기반 에이전트가 AWS EC2에서 자율 운영되며, nad.fun에 직접 $MOT 토큰을 발행하고 Monad 블록체인 위 베팅 시스템을 구현했습니다.",
      "period": "2026.02.09 - 2026.02.16"
    }
  },
  "Experience": {
    "sectionTitle": "경력",
    "paymentInApp": {
      "date": "2022.05 - 2024.03",
      "title": "주식회사 페이먼트인앱 — 사업기획 총괄",
      "company": "주식회사 페이먼트인앱",
      "description": "Joshua AI Agent(Electron/Angular), 제조 불량 인식 자동화(YOLO), 리테일 매장 고객 행동 분석(VanillaJS 대시보드), EMV 서울 교통 타당성 조사 등 다수 프로젝트를 기획·총괄했습니다."
    },
    "dyAccounting": {
      "date": "2017.01 - 2018.12 / 2024.07 - 2025.06",
      "title": "DY Microfinance — 회계·재무 운영 및 CMS 개발",
      "company": "DY Microfinance (미얀마)",
      "description": "1차(2017-2018): 회계·재무 운영 및 BS·PL 자동 생성 스프레드시트 구축. 2차(2024-2025): Next.js, NestJS, PostgreSQL 기반 고객 관리 시스템을 개발하고 관리자 대시보드 구현 및 회계 프로세스 약 90%를 자동화했습니다."
    }
  },
  "Education": {
    "sectionTitle": "학력",
    "sangmyung": {
      "date": "2024.03 - 2026.02",
      "title": "상명대학교 빅데이터융합학과",
      "description": "졸업 예정 | GPA 4.33 / 4.5"
    },
    "yangon": {
      "date": "2017.01 - 2018.12",
      "title": "양곤외국어대학교 미얀마어과",
      "description": "중퇴"
    },
    "certificationsTitle": "자격증 · 수상",
    "certifications": {
      "computerSkills": "컴퓨터활용능력 1급 (2020.11)",
      "accounting": "전산회계 1급 (2021.03)",
      "fsi": "FSI AIxData Challenge 2024 우수상",
      "toeic": "TOEIC 930 (2025.11)"
    },
    "activitiesTitle": "활동",
    "activities": {
      "bay": "연세대학교 블록체인 학회 BAY 17기",
      "aiCourse": "영우글로벌러닝 AI S/W 전문가 양성과정 (2022.04)"
    }
  },
  "ProjectDetail": {
    "sidebar": {
      "role": "역할",
      "teamSize": "팀 규모",
      "duration": "기간",
      "techStack": "기술 스택",
      "links": "링크"
    },
    "joshua": {
      "title": "Joshua AI Agent",
      "subtitle": "KoGPT-2 기반 AI 카피라이팅 에이전트",
      "role": "프론트엔드 개발",
      "teamSize": "4명",
      "duration": "2022.06 - 2023.03",
      "overview": {
        "title": "프로젝트 개요",
        "background": "Joshua AI Agent는 KoGPT-2 언어모델을 기반으로 한 AI 카피라이팅 서비스입니다. 마케팅 콘텐츠와 광고 카피를 생성하는 유료 구독형 데스크톱 애플리케이션으로, Windows와 macOS를 모두 지원하는 크로스플랫폼 환경 구축이 필수였습니다. FastAPI 기반 백엔드와 PostgreSQL 데이터베이스를 활용한 AI 모델 서빙 아키텍처에서 프론트엔드를 담당했습니다. 주된 기술적 과제는 Electron 환경에서 Angular 프레임워크를 통합하고, AI 응답의 실시간 스트리밍 렌더링을 구현하며, Stripe 결제 플로우를 데스크톱 앱 환경에 적합하게 구성하는 것이었습니다.",
        "contribution": "프로젝트에서 프론트엔드 개발 전반을 담당했으며, Electron과 Angular를 결합한 데스크톱 애플리케이션 아키텍처 설계부터 AI 응답 인터페이스 구현, Stripe 결제 연동까지 수행했습니다. 특히 Electron의 Main 프로세스와 Renderer 프로세스 간 IPC(Inter-Process Communication) 통신 구조를 설계하여 백엔드 API와의 통신 로직을 Main 프로세스에서 처리하고, Angular 기반 Renderer 프로세스에서는 순수하게 UI 렌더링과 사용자 인터랙션에 집중할 수 있도록 관심사를 분리했습니다. AI 생성 콘텐츠의 점진적 스트리밍 표시를 위해 RxJS를 활용한 비동기 데이터 처리 파이프라인을 구축했으며, Stripe의 Checkout 세션 기반 결제 플로우를 데스크톱 환경에 맞게 커스터마이징했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "Electron + Angular 크로스플랫폼 데스크톱 앱 아키텍처",
          "problem": "일반적으로 Electron은 React나 Vue와 결합하는 경우가 많고, Angular와의 통합 사례가 상대적으로 적어 레퍼런스가 부족했습니다. Angular의 복잡한 빌드 설정(Webpack, TypeScript 컴파일러)과 Electron의 Main/Renderer 프로세스 구조를 조화롭게 구성해야 했고, 개발 환경과 프로덕션 빌드 환경 모두에서 안정적으로 작동하는 빌드 파이프라인이 필요했습니다. 특히 Angular의 개발 서버를 Electron 프로세스와 연동하는 HMR(Hot Module Replacement) 환경 구성이 핵심 과제였습니다.",
          "solution": "Electron Builder를 활용해 Angular 애플리케이션을 Electron 환경에 패키징하는 빌드 워크플로우를 구축했습니다. Main 프로세스는 순수 TypeScript로 작성하여 BrowserWindow 생성, IPC 핸들러 등록, 백엔드 API 통신 등 네이티브 기능과 시스템 레벨 로직을 담당하게 했습니다. Renderer 프로세스는 Angular CLI 기반으로 빌드된 결과물을 로드하도록 구성했으며, 개발 모드에서는 Angular dev server(localhost:4200)를 Electron이 로드하고, 프로덕션 빌드에서는 file:// 프로토콜로 dist 폴더의 정적 파일을 로드하는 방식으로 환경을 분리했습니다. IPC 통신은 ipcRenderer와 ipcMain을 사용한 request-response 패턴으로 설계해, Renderer에서 사용자 입력을 받으면 Main을 통해 백엔드 API를 호출하고, 응답을 다시 Renderer로 전달하는 단방향 데이터 흐름을 유지했습니다.",
          "result": "Windows와 macOS 양쪽에서 안정적으로 동작하는 크로스플랫폼 데스크톱 앱을 출시할 수 있었습니다. 개발 환경에서는 Angular의 HMR을 활용해 빠른 개발 사이클을 유지하면서도, 프로덕션 빌드에서는 단일 실행 파일(Windows: .exe, macOS: .dmg)로 배포할 수 있는 구조를 확립했습니다. IPC 통신 레이어 덕분에 백엔드 API 변경사항이 있어도 Main 프로세스만 수정하면 되어, Angular 컴포넌트 코드와의 결합도를 낮게 유지할 수 있었습니다."
        },
        "feature2": {
          "title": "AI 응답 실시간 스트리밍 렌더링 인터페이스",
          "problem": "KoGPT-2 모델이 생성하는 텍스트를 사용자에게 보여주는 방식이 중요했습니다. 긴 카피 문구를 한 번에 표시하면 사용자가 대기 시간 동안 아무런 피드백을 받지 못해 UX가 저하되고, 반대로 스트리밍 방식으로 토큰 단위로 점진적으로 표시하면 '생성 중'이라는 느낌을 주어 체감 속도가 빨라집니다. 백엔드에서 Server-Sent Events(SSE) 또는 청크 방식으로 응답을 보내주면, 이를 프론트엔드에서 실시간으로 받아 화면에 렌더링해야 했습니다. Angular 환경에서 비동기 스트림 데이터를 효율적으로 처리하면서 UI를 부드럽게 업데이트하는 방법이 필요했습니다.",
          "solution": "RxJS의 Observable 기반 비동기 처리 파이프라인을 구성했습니다. Electron IPC를 통해 Main 프로세스에서 백엔드 API의 스트리밍 응답을 받으면, 이를 청크 단위로 Renderer 프로세스에 이벤트로 전달하고, Angular 컴포넌트에서 Observable로 구독하여 화면에 반영했습니다. 구체적으로는 백엔드 응답을 fetch API의 ReadableStream으로 읽어들이고, 각 청크를 파싱하여 ipcRenderer.send로 Renderer에 전송하는 방식을 채택했습니다. Angular 컴포넌트에서는 fromEvent로 IPC 이벤트를 Observable화하여 scan 오퍼레이터로 누적 텍스트를 생성하고, async pipe를 통해 템플릿에 바인딩했습니다. 이를 통해 텍스트가 타이핑되는 듯한 자연스러운 애니메이션 효과를 구현했습니다.",
          "result": "사용자는 AI가 카피를 생성하는 과정을 실시간으로 볼 수 있어 대기 시간이 체감상 짧아졌고, 앱 사용 경험이 개선되었습니다. RxJS 기반 아키텍처 덕분에 에러 핸들링(catchError), 타임아웃(timeout), 재시도 로직(retry)을 선언적으로 추가할 수 있었고, 백엔드 API가 불안정해도 프론트엔드에서 안정적으로 대응할 수 있었습니다. 사용자 피드백에서도 '생성 과정이 보여서 좋다'는 긍정적인 반응을 얻었습니다."
        },
        "feature3": {
          "title": "Stripe 결제 연동 및 구독 관리 UI",
          "problem": "유료 구독 모델이었기 때문에 Stripe Checkout을 통한 결제 플로우와 구독 상태 관리 UI가 필수였습니다. 일반적인 웹 앱과 달리 데스크톱 앱 환경에서는 브라우저를 별도로 열어 결제를 진행하고, 결제 완료 후 다시 앱으로 돌아와야 하는 흐름을 구성해야 했습니다. Stripe Checkout Session을 생성하고, 외부 브라우저에서 결제를 완료한 뒤, 앱이 결제 완료 상태를 감지하여 UI를 업데이트하는 로직이 필요했습니다. 또한 사용자가 현재 구독 중인지, 무료 체험 기간인지, 결제가 실패했는지를 명확하게 보여주는 대시보드 인터페이스도 구현해야 했습니다.",
          "solution": "Stripe Checkout의 웹 기반 결제 페이지를 Electron의 shell.openExternal API를 통해 기본 브라우저에서 열도록 구성했습니다. 백엔드에서 Stripe Checkout Session을 생성하면 클라이언트는 해당 URL을 받아 브라우저를 실행하고, 사용자는 Stripe의 안전한 결제 페이지에서 카드 정보를 입력합니다. 결제 완료 후 Stripe Webhook을 통해 백엔드가 사용자 구독 상태를 업데이트하면, 앱은 주기적으로(또는 사용자가 '결제 완료' 버튼을 누르면) 백엔드 API를 polling하여 최신 구독 상태를 가져와 UI를 갱신하는 방식으로 구현했습니다. Angular 서비스 레이어에서 구독 정보를 BehaviorSubject로 관리하여 앱 전역에서 실시간으로 구독 상태를 참조할 수 있게 했고, 구독 만료일, 다음 결제일 등의 정보를 대시보드에 표시했습니다.",
          "result": "데스크톱 앱 환경에서도 안전하고 표준적인 Stripe 결제 플로우를 제공할 수 있었고, 사용자는 앱 내에서 결제 버튼을 누르면 브라우저가 열려 결제를 완료한 뒤 다시 앱으로 돌아오는 자연스러운 경험을 제공받았습니다. 구독 상태 관리 UI 덕분에 사용자는 현재 자신의 구독 플랜과 남은 기간을 명확히 인지할 수 있었고, 고객 지원 문의도 크게 줄었습니다. Stripe Webhook과 polling 방식의 조합으로 결제 완료 이벤트를 놓치지 않고 안정적으로 처리할 수 있었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "Electron IPC 통신 시 대용량 데이터 전송 오류",
          "problem": "AI가 생성한 긴 텍스트나 다량의 히스토리 데이터를 Main 프로세스에서 Renderer 프로세스로 IPC를 통해 전달할 때 간헐적으로 오류가 발생했습니다. 특정 크기 이상의 데이터를 전송하면 Electron이 메모리 부족 에러를 발생시키거나, IPC 채널이 블로킹되어 앱이 멈추는 현상이 관찰되었습니다. 초기에는 ipcRenderer.send와 ipcMain.on을 사용해 모든 데이터를 한 번에 전송하려 했으나, 데이터가 클 경우 직렬화 과정에서 병목이 발생했습니다.",
          "solution": "대용량 데이터는 청크 단위로 분할하여 여러 번 전송하는 스트리밍 방식으로 변경했습니다. ipcRenderer.invoke와 ipcMain.handle을 사용하는 Promise 기반 IPC 패턴으로 전환하고, 데이터를 일정 크기(예: 1MB) 단위로 나누어 순차적으로 전송한 뒤 Renderer에서 조립하는 로직을 구현했습니다. 또한 불필요한 데이터는 전송하지 않도록 백엔드 응답 구조를 최적화하고, 프론트엔드에서는 필요한 필드만 선택적으로 전달받는 GraphQL 스타일의 쿼리 접근 방식을 모방했습니다.",
          "result": "대용량 데이터 전송 시에도 안정적으로 동작하게 되었고, IPC 통신 병목 현상이 해소되어 앱 응답성이 크게 개선되었습니다. 사용자가 긴 히스토리를 조회하거나 다량의 카피를 일괄 생성해도 앱이 멈추지 않고 부드럽게 처리할 수 있었습니다."
        },
        "issue2": {
          "title": "Angular Zone.js와 Electron 이벤트 루프 충돌",
          "problem": "Angular는 Zone.js를 사용해 변경 감지를 자동화하는데, Electron의 IPC 이벤트가 Angular Zone 외부에서 발생하면 UI가 자동으로 업데이트되지 않는 문제가 있었습니다. 특히 ipcRenderer.on으로 등록한 이벤트 리스너에서 컴포넌트 상태를 변경해도 화면에 반영되지 않아, 사용자가 수동으로 다른 화면으로 이동했다가 돌아와야 업데이트가 보이는 상황이 발생했습니다. Zone.js의 동작 원리를 이해하지 못한 채 개발하면서 발생한 문제였습니다.",
          "solution": "NgZone 서비스를 주입하여 IPC 이벤트 핸들러 내에서 zone.run()을 명시적으로 호출해 Angular의 변경 감지 사이클에 진입하도록 수정했습니다. 모든 IPC 이벤트 수신 로직을 Angular 서비스로 캡슐화하고, fromEvent로 Observable화한 뒤 observeOn(asyncScheduler)를 사용해 Angular Zone 내에서 실행되도록 보장했습니다. 이를 통해 IPC 이벤트가 발생하면 자동으로 UI가 업데이트되도록 만들었습니다.",
          "result": "IPC 이벤트 기반 상태 변경이 즉시 화면에 반영되어 사용자 경험이 크게 개선되었습니다. Zone.js의 동작 원리를 깊이 이해하게 되었고, Electron + Angular 환경에서의 이벤트 처리 베스트 프랙티스를 확립할 수 있었습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "Electron과 Angular를 결합한 크로스플랫폼 데스크톱 애플리케이션 개발 경험을 쌓으면서, 웹 기술 스택으로 네이티브 앱을 구축하는 아키텍처에 대한 이해가 깊어졌습니다. IPC 통신 구조 설계, Main/Renderer 프로세스의 역할 분리, Angular Zone.js와 Electron 이벤트 루프의 상호작용 등 웹 프레임워크와 데스크톱 환경을 결합할 때 발생하는 특수한 문제들을 해결하며 많은 것을 배웠습니다. RxJS를 활용한 비동기 데이터 스트리밍 처리 경험은 이후 다른 프로젝트에서도 유용하게 적용할 수 있었고, Stripe 결제 통합을 통해 SaaS 비즈니스 모델의 프론트엔드 구현 역량도 확보했습니다. 특히 AI 모델 응답을 실시간 스트리밍으로 렌더링하는 인터페이스를 구현하며, 단순히 데이터를 보여주는 것을 넘어 사용자에게 '기다림'을 '경험'으로 전환하는 UX 설계의 중요성을 체감했습니다.",
        "improvement": "프로젝트 초기에 Electron과 Angular의 통합 방식에 대한 레퍼런스가 부족해 많은 시행착오를 겪었습니다. 미리 충분한 기술 검증(POC)을 수행하고 아키텍처를 확정했다면 개발 속도를 높일 수 있었을 것입니다. 또한 IPC 통신 레이어에 대한 테스트 코드가 부족해 디버깅에 많은 시간을 소비했는데, Main 프로세스와 Renderer 프로세스 간 통신 로직에 대한 단위 테스트와 통합 테스트를 체계적으로 작성했다면 안정성을 더 높일 수 있었을 것입니다. 성능 최적화 측면에서도 번들 사이즈 최적화(Tree-shaking, Lazy Loading)와 메모리 프로파일링을 더 철저히 수행했다면 앱 실행 속도와 리소스 사용량을 개선할 수 있었을 것으로 생각합니다. 향후 유사한 프로젝트에서는 초기 설계 단계에서 테스트 전략과 성능 목표를 명확히 수립하고, 지속적인 모니터링과 개선을 병행할 계획입니다."
      }
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "subtitle": "고객 관리 시스템",
      "role": "풀스택 개발",
      "teamSize": "1명 (솔로)",
      "duration": "2024.07 - 2025.06",
      "overview": {
        "title": "프로젝트 개요",
        "background": "DY Microfinance CMS는 미얀마 소재 소액금융기관의 고객 관리 및 회계 업무를 자동화하기 위한 웹 기반 관리 시스템입니다. 기존에는 Excel 스프레드시트와 수작업으로 고객 정보, 대출 내역, 회계 장부를 관리하다 보니 데이터 정합성 문제가 빈번했고, 월말 결산 시 수십 시간의 수작업이 필요했습니다. 이를 해결하기 위해 Next.js 기반 프론트엔드와 NestJS 기반 백엔드를 PostgreSQL 데이터베이스로 연결한 분리형 아키텍처를 채택했습니다. 1인 개발자로서 프론트엔드와 백엔드를 모두 담당했으며, 프론트엔드에서는 관리자용 대시보드 UI/UX 설계와 구현, 복잡한 회계 데이터 테이블 관리, 폼 검증 로직 등을 중점적으로 다뤘습니다.",
        "contribution": "전체 시스템 아키텍처 설계부터 배포까지 모든 과정을 담당했으며, 프론트엔드 관점에서는 Next.js App Router 기반의 관리자 대시보드, Server Actions를 활용한 폼 처리, 회계 데이터 테이블 렌더링 최적화, 다국어(미얀마어/영어) 지원 등을 구현했습니다. 대시보드에서는 고객 수, 대출 잔액, 월별 수익 등의 핵심 지표를 실시간으로 시각화하여 경영진이 한눈에 현황을 파악할 수 있도록 했습니다. 회계 프로세스 자동화를 통해 BS(대차대조표)와 PL(손익계산서)을 자동 생성하는 인터페이스를 구축했고, 이를 통해 약 90%의 수작업을 제거하여 월말 결산 시간을 수십 시간에서 수 시간으로 단축했습니다. 또한 사용자(대출 상담사, 회계 담당자, 관리자)별로 권한을 구분하여 각자 필요한 화면과 기능만 접근할 수 있도록 Role-Based Access Control을 프론트엔드 라우팅 레벨에서 구현했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "Next.js 기반 관리자 대시보드 설계 및 구현",
          "problem": "회계 담당자와 관리자가 매일 확인해야 하는 정보가 많았습니다. 고객 수, 대출 잔액, 연체율, 월별 수익, 최근 대출 신청 내역 등 다양한 데이터를 한 화면에서 직관적으로 보여줘야 했고, 데이터가 실시간으로 업데이트되면서도 페이지 로딩 속도가 느려지지 않아야 했습니다. 특히 PostgreSQL에서 집계 쿼리를 수행할 때 시간이 오래 걸리는 경우가 있어, 프론트엔드에서 어떻게 데이터를 가져와 표시할지 전략이 필요했습니다. 또한 미얀마 현지 사용자들의 인터넷 환경이 불안정한 점을 고려하여 오프라인 대응과 데이터 캐싱도 중요한 요구사항이었습니다.",
          "solution": "Next.js App Router의 Server Components를 활용해 대시보드 초기 렌더링 시 서버에서 데이터를 미리 가져와 HTML에 포함시켜 전송하는 방식으로 초기 로딩 속도를 최적화했습니다. 핵심 지표(고객 수, 대출 잔액 등)는 백엔드 API에서 미리 계산된 값을 제공받아 프론트엔드에서는 단순히 표시만 하도록 했고, 복잡한 집계는 PostgreSQL의 Materialized View를 활용해 백엔드에서 주기적으로 갱신하도록 구성했습니다. 차트 렌더링에는 Recharts 라이브러리를 사용해 월별 수익 추이, 대출 상환율 등을 시각화했고, 테이블 컴포넌트는 TanStack Table을 활용해 정렬, 필터링, 페이지네이션 기능을 클라이언트 사이드에서 빠르게 처리할 수 있도록 했습니다. 또한 React Query(TanStack Query)를 도입하여 API 응답을 캐싱하고, stale-while-revalidate 전략으로 사용자가 대시보드를 재방문할 때 캐시된 데이터를 먼저 보여주고 백그라운드에서 최신 데이터를 가져오도록 구성했습니다.",
          "result": "관리자 대시보드 초기 로딩 시간이 3초 이하로 단축되었고, 사용자는 페이지를 열자마자 핵심 지표를 즉시 확인할 수 있게 되었습니다. React Query의 캐싱 덕분에 사용자가 대시보드를 자주 방문해도 불필요한 API 호출이 줄어들어 서버 부하도 감소했습니다. 차트와 테이블이 부드럽게 렌더링되어 사용자 만족도가 높아졌고, 인터넷이 불안정한 환경에서도 캐시된 데이터로 기본적인 정보 확인이 가능해졌습니다."
        },
        "feature2": {
          "title": "프론트엔드-백엔드 분리형 아키텍처와 API 연동",
          "problem": "초기에는 Next.js의 API Routes를 사용해 풀스택 구성으로 개발할지, 아니면 프론트엔드와 백엔드를 완전히 분리할지 고민이었습니다. 향후 모바일 앱이나 다른 클라이언트가 추가될 가능성을 고려하면 백엔드를 독립적인 API 서버로 분리하는 것이 유리했지만, 1인 개발 환경에서 두 개의 프로젝트를 관리하는 부담도 컸습니다. 또한 프론트엔드에서 백엔드 API를 호출할 때 타입 안정성을 유지하고, 인증 토큰 관리, 에러 핸들링 등을 일관되게 처리하는 아키텍처가 필요했습니다.",
          "solution": "Next.js 프론트엔드와 NestJS 백엔드를 분리하되, 개발 환경에서는 Next.js의 rewrites 기능을 활용해 /api/* 경로를 NestJS 서버로 프록시하여 CORS 이슈를 회피했습니다. 프로덕션 환경에서는 Nginx를 리버스 프록시로 사용해 프론트엔드와 백엔드를 동일 도메인에서 서비스하도록 구성했습니다. API 클라이언트는 axios 기반 커스텀 인스턴스를 만들어, 모든 요청에 JWT 토큰을 자동으로 포함시키고, 401 응답 시 자동으로 토큰 갱신을 시도하는 인터셉터를 구현했습니다. 타입 안정성을 위해 백엔드 NestJS에서 정의한 DTO(Data Transfer Object)를 프론트엔드에서 공유하여, TypeScript 타입 추론을 통해 API 요청/응답 구조를 컴파일 타임에 검증할 수 있도록 했습니다. Zod를 사용해 런타임 타입 검증도 추가하여 백엔드 응답이 예상과 다를 경우 즉시 에러를 발생시켜 디버깅을 용이하게 했습니다.",
          "result": "프론트엔드와 백엔드가 명확히 분리되어, 각각의 개발과 배포가 독립적으로 가능해졌습니다. NestJS 백엔드는 RESTful API 서버로 기능하여 향후 모바일 앱이나 외부 시스템과의 연동이 용이한 구조가 되었고, Next.js 프론트엔드는 순수하게 UI/UX에 집중할 수 있었습니다. 타입 공유 구조 덕분에 백엔드 API 변경 시 프론트엔드에서 타입 에러가 즉시 발생하여, 런타임 에러를 사전에 방지할 수 있었습니다. axios 인터셉터를 통한 자동 토큰 갱신 로직으로 사용자가 장시간 대시보드를 사용해도 세션이 끊기지 않아 사용자 경험이 개선되었습니다."
        },
        "feature3": {
          "title": "회계 프로세스 자동화 인터페이스 구현",
          "problem": "기존 회계 프로세스는 대출 내역, 상환 내역, 비용 지출 등의 데이터를 수작업으로 Excel에 입력하고, 월말에 BS와 PL을 수동으로 작성하는 방식이었습니다. 이를 자동화하려면 프론트엔드에서 대출/상환/지출 데이터를 입력받는 폼을 제공하고, 백엔드에서 회계 로직을 수행한 뒤, 결과를 프론트엔드에서 보고서 형태로 출력해야 했습니다. 특히 회계 데이터의 정합성이 중요했기 때문에, 입력 단계에서 엄격한 검증이 필요했고, 사용자가 실수로 잘못된 데이터를 입력하지 않도록 UX 차원에서 가이드를 제공해야 했습니다. 또한 월말 보고서는 PDF로 출력할 수 있어야 했습니다.",
          "solution": "Next.js의 Server Actions를 활용해 폼 제출 시 서버 사이드에서 데이터 검증과 DB 저장을 처리하도록 구성했습니다. 클라이언트 사이드에서는 React Hook Form과 Zod를 조합하여 실시간 폼 검증을 수행하고, 사용자가 필드를 입력할 때마다 즉각적인 피드백(에러 메시지, 성공 인디케이터)을 제공했습니다. 예를 들어 대출 금액 입력 시 숫자만 허용하고, 상환일은 대출일보다 미래여야 한다는 조건을 클라이언트와 서버 양쪽에서 검증했습니다. 월말 보고서 생성 기능은 사용자가 '보고서 생성' 버튼을 누르면 백엔드에서 회계 데이터를 집계하여 BS/PL을 생성하고, 프론트엔드에서는 이를 테이블 형태로 렌더링한 뒤, React-PDF 라이브러리를 사용해 클라이언트 사이드에서 PDF로 변환하여 다운로드할 수 있도록 구현했습니다. 이를 통해 월말 결산 프로세스를 '데이터 입력 → 버튼 클릭 → 보고서 다운로드'의 3단계로 단순화했습니다.",
          "result": "회계 프로세스 자동화로 월말 결산 시간이 기존 수십 시간에서 수 시간으로 단축되었고, 수작업으로 인한 오류(오타, 계산 실수 등)가 거의 사라졌습니다. 사용자는 폼 입력 시 실시간으로 에러 피드백을 받아 잘못된 데이터를 미리 수정할 수 있었고, 보고서를 PDF로 즉시 출력하여 경영진에게 제출할 수 있어 업무 효율이 크게 향상되었습니다. 자동화율 약 90%를 달성하여 회계 담당자의 업무 부담이 대폭 줄어들었고, 데이터 정합성도 크게 개선되었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "대시보드 테이블 렌더링 성능 저하",
          "problem": "고객 수가 수천 명으로 늘어나면서 대시보드의 고객 목록 테이블을 렌더링할 때 브라우저가 버벅이는 현상이 발생했습니다. 초기에는 백엔드에서 전체 고객 데이터를 한 번에 가져와 프론트엔드에서 렌더링했는데, 수천 개의 행을 DOM에 그리다 보니 렌더링 시간이 수 초 걸렸고, 스크롤 시에도 버벅임이 심했습니다. 사용자는 테이블을 빠르게 스크롤하며 특정 고객을 찾고 싶어 했지만, 렌더링 성능 문제로 사용성이 크게 저하되었습니다.",
          "solution": "가상 스크롤링(Virtual Scrolling) 기법을 도입하여 현재 뷰포트에 보이는 행만 DOM에 렌더링하도록 최적화했습니다. TanStack Table의 가상화 기능을 활용해, 수천 개의 데이터가 있어도 실제로는 화면에 보이는 20-30개의 행만 렌더링하고, 스크롤 시 동적으로 DOM을 교체하는 방식으로 변경했습니다. 또한 서버 사이드 페이지네이션을 추가 옵션으로 제공하여, 사용자가 페이지당 50개씩 데이터를 가져오도록 선택할 수 있게 했습니다. 검색 필터 기능도 강화하여 사용자가 이름이나 대출 ID로 필터링하면 해당하는 데이터만 백엔드에서 가져와 렌더링하도록 구성했습니다.",
          "result": "테이블 렌더링 성능이 극적으로 개선되어, 수천 개의 고객 데이터가 있어도 초기 로딩이 1초 이내로 완료되고, 스크롤이 부드럽게 동작하게 되었습니다. 사용자는 빠르게 데이터를 탐색할 수 있었고, 가상 스크롤링 덕분에 메모리 사용량도 크게 줄어들어 저사양 환경에서도 안정적으로 동작했습니다."
        },
        "issue2": {
          "title": "폼 제출 시 중복 요청 방지",
          "problem": "사용자가 대출 신청 폼을 제출할 때 버튼을 여러 번 클릭하거나, 네트워크가 느려서 응답이 늦어지면 같은 데이터가 중복으로 DB에 저장되는 문제가 발생했습니다. 특히 미얀마 현지의 불안정한 인터넷 환경에서는 사용자가 '제출' 버튼을 누른 후 아무 반응이 없어 다시 누르는 경우가 빈번했습니다. 이로 인해 동일한 대출 신청이 두 번 생성되는 등의 데이터 정합성 문제가 발생했습니다.",
          "solution": "프론트엔드에서 폼 제출 시 버튼을 즉시 비활성화(disabled)하고, 로딩 인디케이터(스피너)를 표시하여 사용자에게 '처리 중'임을 명확히 알렸습니다. React Hook Form의 isSubmitting 상태를 활용해 제출 중에는 버튼을 클릭할 수 없도록 막았고, Server Action이 완료되면 성공 메시지를 표시하거나 에러 메시지를 보여주는 피드백을 추가했습니다. 백엔드에서도 멱등성(Idempotency) 처리를 추가하여, 동일한 요청이 짧은 시간 내에 여러 번 들어오면 첫 번째 요청만 처리하고 나머지는 무시하도록 Redis 기반 중복 요청 체크 로직을 구현했습니다. 또한 Optimistic UI 패턴을 적용하여 폼 제출 즉시 UI를 업데이트하고, 백엔드 응답을 기다린 뒤 확정하는 방식으로 사용자 경험을 개선했습니다.",
          "result": "중복 요청으로 인한 데이터 정합성 문제가 완전히 해결되었고, 사용자는 폼 제출 후 즉시 피드백을 받아 '처리 중'임을 명확히 인지할 수 있었습니다. 네트워크가 느린 환경에서도 사용자가 여러 번 버튼을 누르지 않게 되어, 불필요한 요청이 줄어들었고 서버 부하도 감소했습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "1인 풀스택 개발자로서 프론트엔드와 백엔드를 모두 설계하고 구현하면서 웹 애플리케이션의 전체 아키텍처에 대한 이해가 깊어졌습니다. 특히 Next.js의 App Router, Server Components, Server Actions 등 최신 기능을 실전에서 활용하며 SSR과 CSR의 장단점을 체감했고, 어떤 상황에서 어떤 렌더링 전략을 선택해야 하는지 판단할 수 있게 되었습니다. 프론트엔드-백엔드 분리형 아키텍처를 구성하며 API 설계, 타입 안정성 확보, 인증/인가 처리 등 실무에서 필수적인 역량을 쌓았습니다. 또한 대시보드와 데이터 시각화 UI를 구현하며 복잡한 비즈니스 로직을 사용자 친화적인 인터페이스로 풀어내는 UX 설계 능력을 향상시켰습니다. 특히 회계 프로세스 자동화를 통해 단순히 '기능 구현'을 넘어 '비즈니스 임팩트'를 만들어내는 개발의 가치를 체감했고, 사용자 피드백을 반영하여 지속적으로 개선하는 과정에서 큰 보람을 느꼈습니다.",
        "improvement": "프로젝트 초기에 테스트 코드 작성을 미루다 보니, 기능 추가 시 기존 기능이 깨지는 리그레션 이슈가 종종 발생했습니다. 특히 회계 로직처럼 정확성이 중요한 부분에서는 단위 테스트와 통합 테스트가 필수적인데, 일정에 쫓겨 생략한 것이 아쉬웠습니다. 향후에는 TDD(Test-Driven Development) 또는 최소한 핵심 비즈니스 로직에 대한 테스트 커버리지를 확보하는 습관을 들이고 싶습니다. 또한 CI/CD 파이프라인 구축도 미흡했습니다. 수동으로 서버에 SSH 접속하여 배포하는 방식이었는데, GitHub Actions 등을 활용한 자동화된 배포 파이프라인을 구축했다면 배포 속도와 안정성을 높일 수 있었을 것입니다. 성능 모니터링 측면에서도 Sentry나 LogRocket 같은 툴을 도입해 프로덕션 환경에서 발생하는 에러와 성능 병목을 실시간으로 추적했다면 더 빠르게 문제를 해결할 수 있었을 것입니다. 다음 프로젝트에서는 테스트, CI/CD, 모니터링을 초기부터 계획하여 보다 안정적이고 유지보수 가능한 시스템을 구축할 계획입니다."
      }
    },
    "retailAnalysis": {
      "title": "리테일 매장 고객 행동 분석",
      "subtitle": "시각지능 기반 고객 동선 분석 시스템",
      "role": "데이터 시각화 개발",
      "teamSize": "3명",
      "duration": "2022.11 - 2023.04",
      "overview": {
        "title": "프로젝트 개요",
        "background": "말레이시아 소재 리테일 매장에서 YOLO 객체 인식 모델을 활용해 매장 내 고객의 동선을 실시간으로 추적하고 분석하는 시스템입니다. CCTV 영상에서 고객의 위치와 이동 경로를 인식하여, 어느 진열대에서 얼마나 머물렀는지, 어떤 동선으로 매장을 이동했는지 등의 데이터를 수집합니다. 이를 통해 매장 관리자는 고객의 행동 패턴을 이해하고, 진열 위치 최적화나 동선 개선 등의 인사이트를 얻을 수 있습니다. 백엔드에서는 PyTorch로 구현된 YOLO 모델이 실시간 영상 처리를 수행하고, 프론트엔드에서는 이 데이터를 받아 대시보드 형태로 시각화하는 역할을 담당했습니다. 프론트엔드 기술 스택으로는 의도적으로 VanillaJS(순수 JavaScript)를 선택했는데, 이는 React나 Vue 같은 프레임워크 없이도 복잡한 실시간 데이터 시각화를 구현할 수 있는지 검증하고, 번들 사이즈와 성능을 최적화하기 위함이었습니다.",
        "contribution": "프로젝트에서 프론트엔드 데이터 시각화 전반을 담당했으며, VanillaJS로 실시간 대시보드를 구축했습니다. 백엔드 팀이 WebSocket을 통해 전송하는 고객 위치 데이터를 받아, Canvas API와 SVG를 활용한 히트맵과 동선 트래킹 시각화를 구현했습니다. 매장 평면도 위에 고객의 현재 위치를 실시간으로 표시하고, 시간대별 고객 밀집도를 색상 그라데이션으로 나타내는 히트맵을 그렸으며, 개별 고객의 이동 경로를 선으로 연결하여 동선을 추적할 수 있도록 했습니다. 또한 통계 차트(시간대별 방문자 수, 구역별 체류 시간 등)를 Chart.js 라이브러리를 활용해 구현했습니다. 프레임워크 없이 상태 관리와 DOM 조작을 수행해야 했기 때문에, 간단한 상태 관리 패턴(Observer 패턴)과 컴포넌트 분리 구조를 직접 설계했습니다. 실시간으로 들어오는 데이터를 효율적으로 처리하기 위해 렌더링 최적화(RequestAnimationFrame, Debouncing)를 적용했고, 메모리 누수를 방지하기 위한 이벤트 리스너 정리 로직도 구현했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "VanillaJS 기반 실시간 데이터 시각화 대시보드",
          "problem": "React나 Vue 같은 프레임워크 없이 복잡한 실시간 대시보드를 구현해야 했습니다. 프레임워크가 제공하는 컴포넌트 구조, 상태 관리, 가상 DOM 등의 편의 기능 없이, 순수 JavaScript로 WebSocket 데이터를 받아 Canvas와 SVG에 실시간으로 렌더링하고, 사용자 인터랙션(줌, 팬, 시간대 필터링 등)을 처리해야 했습니다. 특히 초당 수십 개의 위치 데이터가 들어올 때 DOM을 직접 조작하면 성능 저하가 발생할 수 있어, 효율적인 렌더링 전략이 필요했습니다. 또한 코드 구조가 스파게티 코드로 변질되지 않도록 모듈화와 관심사 분리를 고민해야 했습니다.",
          "solution": "ES6 Modules를 활용해 코드를 기능별로 모듈화했습니다. WebSocket 통신을 담당하는 DataService 모듈, Canvas 렌더링을 담당하는 HeatmapRenderer 모듈, SVG 동선 렌더링을 담당하는 PathRenderer 모듈, 차트 렌더링을 담당하는 ChartRenderer 모듈 등으로 분리했습니다. 상태 관리는 간단한 Observer 패턴을 구현하여, DataService가 새로운 데이터를 받으면 등록된 렌더러들에게 알림(notify)을 보내 각자 업데이트하도록 했습니다. Canvas 렌더링은 requestAnimationFrame을 활용해 브라우저의 리페인트 주기에 맞춰 렌더링하여 부드러운 애니메이션을 구현했고, 불필요한 렌더링을 줄이기 위해 데이터가 변경되었을 때만 다시 그리도록 조건을 설정했습니다. 히트맵은 2D 배열에 고객 체류 시간을 누적하고, 이를 색상 그라데이션으로 변환하여 Canvas에 그리는 방식으로 구현했습니다. SVG는 각 고객의 이동 경로를 path 엘리먼트로 표현하여 동적으로 추가/제거했습니다. 사용자 인터랙션(드래그로 화면 이동, 마우스 휠로 줌)은 이벤트 리스너를 등록하여 Canvas transform을 조작하는 방식으로 처리했습니다.",
          "result": "프레임워크 없이도 안정적이고 성능이 우수한 실시간 대시보드를 구현할 수 있었습니다. 번들 사이즈가 작아(Chart.js 제외 시 100KB 미만) 초기 로딩이 매우 빨랐고, Canvas 기반 렌더링 덕분에 수백 개의 데이터 포인트를 동시에 표시해도 60fps를 유지할 수 있었습니다. 모듈화된 코드 구조 덕분에 새로운 시각화 기능(예: 특정 구역 클릭 시 상세 정보 표시)을 추가할 때도 다른 모듈에 영향을 주지 않고 독립적으로 개발할 수 있었습니다. 매장 관리자는 대시보드를 통해 실시간으로 고객 동선을 모니터링하고, 시간대별 패턴을 분석하여 매장 레이아웃 개선에 활용할 수 있었습니다."
        },
        "feature2": {
          "title": "Canvas 기반 고객 동선 히트맵 및 트래킹 UI",
          "problem": "매장 평면도 위에 고객의 동선을 직관적으로 표현해야 했습니다. 수십 명의 고객이 동시에 이동하는 상황에서 각 고객의 위치와 이동 경로를 실시간으로 표시하면서도, 전체적인 패턴(어느 구역이 인기 있는지, 어떤 동선이 많은지)을 한눈에 파악할 수 있는 시각화가 필요했습니다. 히트맵은 시간이 지남에 따라 누적되는 데이터를 색상으로 표현해야 하고, 동선 트래킹은 개별 고객의 경로를 선으로 연결하여 보여줘야 했습니다. 또한 사용자가 시간대를 선택하면 해당 시간대의 데이터만 필터링하여 보여주는 기능도 필요했습니다.",
          "solution": "Canvas API를 활용해 매장 평면도를 배경으로 그리고, 그 위에 히트맵 레이어와 동선 레이어를 오버레이하는 방식으로 구현했습니다. 히트맵은 매장을 그리드로 나누고(예: 1m x 1m), 각 그리드 셀에 고객이 머문 시간을 누적한 뒤, 값의 크기에 따라 파란색(낮음) → 초록색(중간) → 빨간색(높음) 그라데이션으로 표현했습니다. Canvas의 fillRect와 createLinearGradient를 활용해 부드러운 색상 전환을 구현했습니다. 동선 트래킹은 각 고객의 이동 경로를 배열에 저장하고, Canvas의 lineTo와 stroke를 사용해 경로를 선으로 그렸습니다. 시간대 필터링은 사용자가 슬라이더를 조작하면 해당 시간 범위의 데이터만 필터링하여 히트맵과 동선을 다시 렌더링하도록 구현했습니다. 데이터가 많을 때 성능을 위해, 전체 데이터를 미리 계산하여 캐싱하고, 필터링 시에는 캐시된 데이터를 참조하여 빠르게 렌더링했습니다. 또한 고객이 특정 구역을 클릭하면 해당 구역의 상세 통계(평균 체류 시간, 방문 고객 수 등)를 툴팁으로 표시하는 인터랙션도 추가했습니다.",
          "result": "매장 관리자는 히트맵을 통해 '어느 진열대가 가장 인기 있는지', '고객이 잘 가지 않는 사각지대는 어디인지'를 시각적으로 파악할 수 있었습니다. 동선 트래킹을 통해 '입구에서 들어온 고객이 주로 어떤 경로로 이동하는지', '계산대까지 가는 동선이 효율적인지' 등을 분석할 수 있었습니다. 시간대 필터링 기능 덕분에 평일 오전, 주말 저녁 등 시간대별 패턴 차이를 비교할 수 있었고, 이를 바탕으로 진열 위치나 프로모션 전략을 조정하는 데 활용되었습니다. Canvas 기반 렌더링으로 수백 개의 경로를 동시에 표시해도 성능 저하 없이 부드럽게 동작했습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "실시간 데이터 렌더링 시 메모리 누수",
          "problem": "대시보드를 장시간 실행하면 브라우저의 메모리 사용량이 계속 증가하여 결국 브라우저가 느려지거나 크래시되는 문제가 발생했습니다. 초기에는 WebSocket으로 들어오는 데이터를 계속 배열에 누적하고, Canvas를 렌더링할 때마다 전체 데이터를 순회하며 그렸는데, 시간이 지날수록 배열 크기가 커져 렌더링 속도가 느려지고 메모리를 과도하게 사용하게 되었습니다. 또한 이벤트 리스너를 제대로 정리하지 않아 메모리 누수가 발생했습니다.",
          "solution": "데이터 보관 전략을 수정하여, 일정 시간(예: 1시간) 이상 지난 데이터는 자동으로 삭제하도록 했습니다. 순환 버퍼(Circular Buffer) 패턴을 적용해 최대 데이터 크기를 제한하고, 새로운 데이터가 들어오면 가장 오래된 데이터를 제거하는 방식으로 변경했습니다. 렌더링 최적화를 위해 전체 데이터를 매번 그리지 않고, 변경된 부분만 다시 그리는 부분 업데이트 방식을 도입했습니다. 이벤트 리스너는 컴포넌트가 제거될 때(페이지 이동 시) removeEventListener를 호출하여 명시적으로 정리했습니다. WebSocket 연결도 페이지를 벗어날 때 close()를 호출하여 연결을 종료했습니다. 또한 Chrome DevTools의 Performance Monitor와 Memory Profiler를 활용해 메모리 누수 지점을 찾아 수정했습니다.",
          "result": "메모리 누수가 해결되어 대시보드를 하루 종일 실행해도 브라우저가 안정적으로 동작하게 되었습니다. 메모리 사용량이 일정 수준 이하로 유지되었고, 렌더링 성능도 개선되어 장시간 사용해도 부드러운 애니메이션을 유지할 수 있었습니다. 매장 관리자는 대시보드를 계속 켜두고 실시간으로 모니터링할 수 있게 되었습니다."
        },
        "issue2": {
          "title": "VanillaJS 환경에서 상태 관리 복잡도 증가",
          "problem": "프레임워크 없이 순수 JavaScript로 개발하다 보니, 상태 관리가 점점 복잡해졌습니다. 여러 모듈이 동일한 데이터를 참조하고 수정하면서 데이터 동기화 문제가 발생했고, 어떤 모듈이 데이터를 변경했는지 추적하기 어려워 디버깅이 힘들었습니다. 특히 사용자가 필터를 변경하면 여러 차트와 히트맵을 동시에 업데이트해야 했는데, 각 모듈을 수동으로 호출하다 보니 코드가 복잡해지고 에러가 발생하기 쉬웠습니다.",
          "solution": "간단한 상태 관리 라이브러리를 직접 구현했습니다. Observer 패턴을 기반으로 중앙 Store 객체를 만들고, 각 모듈(렌더러, 차트 등)은 Store를 구독(subscribe)하여 데이터가 변경되면 자동으로 알림을 받도록 했습니다. Store는 상태를 불변(immutable) 방식으로 관리하여, 상태 변경 시 새로운 객체를 반환하고, 이전 상태와 비교하여 실제로 변경된 부분만 렌더링하도록 최적화했습니다. 상태 변경 로직은 Actions 객체에 정의하여, 모든 상태 변경이 명시적인 액션을 통해 이루어지도록 구조화했습니다. 이를 통해 Redux와 유사한 단방향 데이터 흐름을 VanillaJS 환경에서 구현했습니다. 디버깅을 위해 상태 변경 이력을 콘솔에 로깅하는 미들웨어도 추가했습니다.",
          "result": "상태 관리가 명확해지고 예측 가능해졌습니다. 데이터 변경이 발생하면 구독 중인 모든 모듈이 자동으로 업데이트되어, 수동으로 각 모듈을 호출할 필요가 없어졌습니다. 버그 발생 시 상태 변경 이력을 추적하여 원인을 빠르게 파악할 수 있었고, 새로운 기능 추가 시에도 기존 코드를 수정하지 않고 새로운 모듈을 구독시키기만 하면 되어 유지보수성이 크게 향상되었습니다. VanillaJS로도 충분히 복잡한 상태 관리가 가능하다는 것을 증명했지만, 동시에 React나 Vue 같은 프레임워크가 제공하는 가치(컴포넌트 구조, 가상 DOM, 개발자 도구 등)를 더욱 체감하게 되었습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "프레임워크 없이 VanillaJS로 복잡한 실시간 대시보드를 구현하면서, JavaScript의 근본적인 동작 원리와 브라우저 렌더링 메커니즘에 대한 이해가 깊어졌습니다. Canvas API와 SVG를 직접 다루며 저수준 그래픽 렌더링 경험을 쌓았고, WebSocket을 통한 실시간 데이터 처리와 메모리 관리, 성능 최적화 등 실무 프론트엔드 개발에서 중요한 역량을 강화했습니다. 특히 상태 관리 패턴을 직접 설계하고 구현하면서, React나 Vue에서 제공하는 상태 관리 라이브러리가 내부적으로 어떻게 동작하는지 이해할 수 있었고, 이후 Redux나 Vuex를 사용할 때 더 깊이 있는 활용이 가능해졌습니다. 메모리 누수와 렌더링 성능 문제를 해결하며 Chrome DevTools를 활용한 프로파일링 기법을 익혔고, requestAnimationFrame, Debouncing, Observer 패턴 등 실무에서 자주 쓰이는 최적화 패턴을 실전에서 적용해보는 귀중한 경험을 했습니다. Canvas 기반 데이터 시각화를 통해 대용량 데이터를 효율적으로 표현하는 방법을 배웠고, 이는 이후 다른 프로젝트에서 차트나 그래프를 구현할 때 큰 도움이 되었습니다.",
        "improvement": "VanillaJS로 개발하면서 프레임워크의 필요성을 절감했습니다. 컴포넌트 재사용성, 선언적 UI, 가상 DOM 등 모던 프레임워크가 제공하는 편의 기능 없이 모든 것을 수동으로 구현하다 보니 개발 속도가 느리고 코드 중복이 많았습니다. 특히 여러 모듈 간 데이터 동기화나 DOM 업데이트 로직을 수동으로 관리하는 것이 번거로웠고, 실수로 인한 버그가 자주 발생했습니다. 만약 React를 사용했다면 상태 관리는 useState나 useReducer로 간단히 처리하고, Canvas 렌더링은 useEffect로 관리하여 코드를 훨씬 간결하게 작성할 수 있었을 것입니다. 또한 컴포넌트 기반 구조로 차트, 히트맵, 동선 등을 독립적인 컴포넌트로 분리하여 재사용성과 테스트 용이성을 높일 수 있었을 것입니다. 프로젝트 후반부에는 '이 정도 규모라면 React를 쓰는 게 맞았다'는 생각이 들었고, VanillaJS는 작은 규모의 인터랙티브 요소나 레거시 시스템 유지보수에는 적합하지만, 복잡한 SPA를 구축하기에는 한계가 있다는 것을 체감했습니다. 향후 유사한 프로젝트에서는 기술 선택 단계에서 프로젝트 규모와 복잡도를 고려하여, 적절한 프레임워크를 선택하는 것이 중요하다는 교훈을 얻었습니다. 다음에는 React + D3.js 조합으로 더 나은 구조의 데이터 시각화 대시보드를 구축해보고 싶습니다."
      }
    },
    "scholarlyChain": {
      "title": "Scholarly Chain",
      "subtitle": "Hyperledger Fabric 블록체인 기반 학생회비 관리 시스템",
      "role": "프론트엔드 개발 (100%)",
      "teamSize": "4명",
      "duration": "2025.03 - 2025.06",
      "overview": {
        "title": "프로젝트 개요",
        "background": "Scholarly Chain은 캡스톤 디자인 과제로 진행한 Hyperledger Fabric 블록체인 기반 학생회비 투명 관리 시스템입니다. 학생회비 수입과 지출 내역을 블록체인에 기록하여 투명성을 확보하고, 학생들이 학생회비 사용 내역을 실시간으로 확인할 수 있도록 하는 것이 목표였습니다. Next.js, React, TypeScript, Tailwind CSS, shadcn/ui를 기반으로 한 프론트엔드를 100% 담당했으며, Firebase Cloud Messaging을 활용한 역할별 푸시 알림과 JWT 기반 인증을 구현했습니다. 백엔드는 Hyperledger Fabric 블록체인 네트워크와 연동되어 있었고, 프론트엔드는 백엔드 API를 호출하여 블록체인 데이터를 사용자에게 제공하는 역할을 수행했습니다.",
        "contribution": "4인 팀에서 프론트엔드 개발을 전담했으며, 15개 이상의 페이지와 30개 이상의 재사용 가능한 컴포넌트를 제작했습니다. JWT 토큰 자동 갱신 미들웨어를 구현하여 사용자 세션 끊김을 방지했고, 학생, 위원, 관리자의 3가지 역할에 따라 서로 다른 대시보드와 기능을 제공하는 역할 기반 UI 시스템을 설계했습니다. shadcn/ui 컴포넌트 라이브러리를 활용하여 일관된 디자인 시스템을 구축했으며, Firebase Cloud Messaging을 연동하여 학생회비 입금 확인, 지출 승인 등의 알림을 역할에 따라 선택적으로 전송하는 푸시 알림 시스템을 구현했습니다. Next.js API Routes를 프록시로 활용하여 백엔드 API 호출을 중계했고, Vercel에 배포하여 실제 서비스 환경을 구성했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "JWT 자동 갱신 미들웨어",
          "problem": "사용자가 대시보드를 사용하는 중에 JWT 액세스 토큰이 만료되면 API 호출이 실패하고 세션이 끊겨 다시 로그인해야 하는 문제가 있었습니다. 특히 학생회 관리자가 장시간 지출 내역을 검토하거나 승인 작업을 수행할 때 토큰 만료로 인한 중단은 사용자 경험을 크게 저하시켰습니다. 액세스 토큰은 보안상 짧은 유효 기간을 가져야 하지만, 매번 사용자에게 재로그인을 요구하는 것은 비현실적이었습니다. 리프레시 토큰을 활용해 자동으로 액세스 토큰을 갱신하는 메커니즘이 필요했습니다.",
          "solution": "Next.js의 middleware 기능을 활용하여 모든 API 요청을 가로채고, 액세스 토큰 만료 여부를 확인하는 로직을 구현했습니다. 미들웨어에서 JWT 토큰의 만료 시간을 디코딩하여 검사하고, 만료가 임박하거나 이미 만료된 경우 자동으로 리프레시 토큰을 사용해 새로운 액세스 토큰을 발급받도록 구성했습니다. 리프레시 요청이 성공하면 새로운 토큰을 쿠키에 저장하고, 원래 요청을 재시도하여 사용자가 토큰 갱신 과정을 인지하지 못하도록 했습니다. 만약 리프레시 토큰도 만료되었다면 로그인 페이지로 리디렉션하여 재인증을 요구했습니다.",
          "result": "사용자는 장시간 대시보드를 사용해도 세션이 자동으로 유지되어, 중간에 끊김 없이 작업을 계속할 수 있게 되었습니다. 토큰 갱신 과정이 백그라운드에서 자동으로 처리되어 사용자 경험이 크게 개선되었고, 보안과 편의성을 동시에 확보할 수 있었습니다. 관리자 피드백에서도 '작업 중에 로그아웃되지 않아 편리하다'는 긍정적인 반응을 얻었습니다."
        },
        "feature2": {
          "title": "역할 기반 UI 시스템",
          "problem": "학생, 위원, 관리자의 3가지 역할은 각각 다른 권한과 기능을 필요로 했습니다. 학생은 학생회비 사용 내역을 조회만 할 수 있고, 위원은 지출 신청을 작성할 수 있으며, 관리자는 지출 승인과 전체 데이터 관리 권한을 가집니다. 모든 사용자가 동일한 화면을 보는 것이 아니라, 역할에 따라 맞춤화된 대시보드와 메뉴를 제공해야 했습니다. 또한 권한이 없는 페이지에 접근을 시도할 경우 이를 차단하고 적절한 피드백을 제공해야 했습니다. 역할별로 서로 다른 컴포넌트를 조건부로 렌더링하면서도 코드 중복을 최소화하고 유지보수성을 유지하는 것이 과제였습니다.",
          "solution": "shadcn/ui 컴포넌트 라이브러리를 도입하여 일관된 디자인 시스템을 구축하고, 역할별로 다른 UI를 조건부로 렌더링하는 구조를 설계했습니다. 사용자 인증 시 백엔드에서 받은 역할 정보를 React Context에 저장하고, 모든 컴포넌트에서 현재 사용자의 역할을 참조할 수 있도록 했습니다. 페이지 수준에서는 Next.js의 middleware를 활용해 역할 기반 접근 제어를 구현하여, 권한이 없는 사용자가 특정 페이지에 접근하려 하면 403 에러 페이지로 리디렉션했습니다. 컴포넌트 수준에서는 역할별로 다른 대시보드 레이아웃을 보여주는 RoleBasedDashboard 컴포넌트를 작성하여, 학생용, 위원용, 관리자용 인터페이스를 각각 구성했습니다. shadcn/ui의 Card, Table, Form 등의 컴포넌트를 재사용하여 코드 중복을 줄이고, Tailwind CSS로 역할별 테마 색상을 다르게 적용하여 시각적으로 구분했습니다.",
          "result": "각 역할의 사용자는 자신에게 필요한 기능과 정보만 명확하게 제공받아, 혼란 없이 시스템을 사용할 수 있었습니다. shadcn/ui 덕분에 일관된 디자인 시스템을 유지하면서도 역할별 커스터마이징이 용이했고, 새로운 역할이나 권한을 추가할 때도 기존 구조를 그대로 활용할 수 있었습니다. 사용자 피드백에서 '내가 필요한 기능만 보여서 직관적이다'는 평가를 받았습니다."
        },
        "feature3": {
          "title": "FCM 역할별 푸시 알림 시스템",
          "problem": "학생회비와 관련된 중요한 이벤트(입금 확인, 지출 신청, 지출 승인 등)가 발생했을 때 사용자에게 실시간으로 알림을 전달해야 했습니다. 하지만 모든 사용자에게 모든 알림을 보내는 것은 불필요하고, 역할에 따라 관련된 알림만 선택적으로 전송해야 했습니다. 예를 들어 지출 신청이 제출되면 관리자에게만 알림을 보내고, 지출이 승인되면 해당 신청을 한 위원에게만 알림을 보내야 했습니다. 웹 환경에서 푸시 알림을 구현하고, 사용자가 알림을 클릭하면 관련 페이지로 이동하는 인터랙션도 필요했습니다.",
          "solution": "Firebase Cloud Messaging(FCM)을 연동하여 웹 푸시 알림 기능을 구현했습니다. 사용자가 로그인하면 FCM 토큰을 발급받아 백엔드에 전송하고, 백엔드는 사용자의 역할과 FCM 토큰을 매핑하여 데이터베이스에 저장했습니다. 백엔드에서 특정 이벤트가 발생하면, 해당 이벤트와 관련된 역할의 사용자들에게만 FCM API를 통해 푸시 알림을 전송하도록 구성했습니다. 프론트엔드에서는 Service Worker를 등록하여 백그라운드에서도 푸시 알림을 수신할 수 있도록 했고, 알림을 클릭하면 관련 페이지(예: 지출 승인 대기 목록)로 자동 이동하는 로직을 구현했습니다. 알림 권한 요청 UI도 사용자 친화적으로 디자인하여, 처음 로그인 시 알림 설정을 안내하도록 했습니다.",
          "result": "사용자는 중요한 이벤트를 실시간으로 알림받아 즉각 대응할 수 있게 되었고, 역할별 필터링 덕분에 불필요한 알림이 줄어들어 알림 피로도가 낮았습니다. 관리자는 새로운 지출 신청을 즉시 확인하고 승인 처리할 수 있었으며, 위원은 자신의 신청이 승인되었는지 실시간으로 알 수 있어 업무 효율이 크게 향상되었습니다. FCM을 통한 푸시 알림은 시스템의 반응성과 사용자 참여도를 높이는 핵심 기능으로 자리 잡았습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "API Route 프록시 패턴에서 발생한 인증 토큰 전달 이슈",
          "problem": "프론트엔드에서 백엔드 API를 직접 호출하는 대신 Next.js API Routes를 프록시로 활용하여 CORS 이슈를 회피하고 보안을 강화하려 했습니다. 하지만 클라이언트에서 API Route로 요청을 보낼 때 쿠키에 저장된 JWT 토큰을 함께 전달하고, API Route에서 다시 백엔드로 요청을 보낼 때도 이 토큰을 정확히 전달해야 했는데, 토큰 전달 과정에서 누락되거나 형식이 맞지 않아 인증 실패가 발생하는 문제가 빈번했습니다. 특히 httpOnly 쿠키로 저장된 토큰을 서버 사이드에서 읽어와 백엔드에 전달하는 로직이 복잡했고, 에러 핸들링도 일관되지 않아 디버깅이 어려웠습니다.",
          "solution": "API Route에서 들어오는 요청의 쿠키를 파싱하여 JWT 토큰을 추출하고, 이를 Authorization 헤더에 담아 백엔드로 전달하는 표준화된 프록시 함수를 작성했습니다. 모든 API Route는 이 공통 프록시 함수를 사용하도록 구조화하여, 토큰 전달 로직을 중앙화했습니다. 백엔드로부터 401 또는 403 응답이 오면 클라이언트에 동일한 상태 코드와 에러 메시지를 반환하여, 프론트엔드에서 일관된 에러 처리를 할 수 있도록 했습니다. 또한 개발 환경과 프로덕션 환경에서 쿠키 설정(Secure, SameSite)이 달라야 했기 때문에, 환경 변수를 통해 동적으로 쿠키 옵션을 설정하는 유틸리티 함수를 만들었습니다.",
          "result": "API Route 프록시 패턴이 안정화되어 인증 토큰 전달 문제가 해결되었고, CORS 이슈 없이 안전하게 백엔드 API를 호출할 수 있게 되었습니다. 공통 프록시 함수 덕분에 새로운 API 엔드포인트를 추가할 때도 일관된 방식으로 구현할 수 있었고, 에러 핸들링이 표준화되어 디버깅 시간이 크게 단축되었습니다."
        },
        "issue2": {
          "title": "shadcn/ui 컴포넌트 커스터마이징과 디자인 시스템 일관성 유지",
          "problem": "shadcn/ui는 Radix UI 기반의 헤드리스 컴포넌트 라이브러리로, 스타일링은 개발자가 직접 해야 했습니다. 프로젝트에서 30개 이상의 재사용 컴포넌트를 제작하면서, 각 컴포넌트의 스타일이 일관되지 않고 Tailwind CSS 클래스가 중복되어 관리가 어려웠습니다. 특히 Button, Card, Form 등 기본 컴포넌트를 여러 페이지에서 다르게 커스터마이징하다 보니, 디자인 시스템의 일관성이 깨지고 유지보수가 힘들어졌습니다. 또한 다크 모드를 지원해야 했는데, 모든 컴포넌트에서 다크 모드 스타일을 일일이 지정하는 것은 비효율적이었습니다.",
          "solution": "Tailwind CSS의 @layer 기능을 활용하여 커스텀 유틸리티 클래스를 정의하고, shadcn/ui 컴포넌트에서 재사용할 수 있는 공통 스타일 클래스를 생성했습니다. 예를 들어 btn-primary, card-base 같은 추상화된 클래스를 만들어, 모든 버튼과 카드가 동일한 기본 스타일을 갖도록 했습니다. 색상, 간격, 글꼴 크기 등의 디자인 토큰을 Tailwind 설정 파일에 미리 정의하여, 컴포넌트에서는 토큰을 참조하는 방식으로 스타일링했습니다. 다크 모드는 Tailwind의 dark: 접두사를 활용하여 자동으로 전환되도록 구성했고, next-themes 라이브러리로 테마 전환 기능을 구현했습니다. 컴포넌트 라이브러리를 src/components/ui 폴더에 모아두고, 각 컴포넌트의 props와 스타일 옵션을 문서화하여 팀원들이 일관되게 사용할 수 있도록 가이드를 제공했습니다.",
          "result": "디자인 시스템의 일관성이 크게 향상되었고, 새로운 페이지나 기능을 추가할 때도 기존 컴포넌트를 재사용하여 빠르게 개발할 수 있었습니다. Tailwind CSS의 유틸리티 클래스 덕분에 스타일링이 간결해졌고, 다크 모드 전환도 자연스럽게 동작하여 사용자 경험이 향상되었습니다. 컴포넌트 문서화 덕분에 팀원 간 협업이 원활해졌고, 디자인 수정이 필요할 때도 중앙화된 스타일 클래스만 수정하면 되어 유지보수성이 높아졌습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "Next.js와 shadcn/ui를 활용한 대규모 프론트엔드 프로젝트를 처음부터 끝까지 주도하면서, 현대적인 프론트엔드 개발 스택에 대한 실무 역량을 크게 강화할 수 있었습니다. JWT 인증 미들웨어와 역할 기반 접근 제어를 구현하며 웹 애플리케이션의 보안과 권한 관리에 대한 깊은 이해를 얻었고, Firebase Cloud Messaging을 통한 푸시 알림 시스템 구축으로 실시간 통신 기술 경험도 쌓았습니다. 특히 4인 팀에서 프론트엔드를 전담하며 15개 이상의 페이지와 30개 이상의 재사용 컴포넌트를 제작한 경험은, 큰 규모의 프로젝트를 독립적으로 설계하고 구현하는 능력을 키우는 데 큰 도움이 되었습니다. shadcn/ui와 Tailwind CSS를 활용한 디자인 시스템 구축 경험은 컴포넌트 재사용성과 일관성을 유지하는 방법을 체득하게 했고, API Route 프록시 패턴을 통해 프론트엔드-백엔드 통신 아키텍처를 설계하는 역량도 향상되었습니다.",
        "improvement": "프로젝트 초기에 테스트 코드를 작성하지 않아, 기능이 추가될수록 리그레션 버그가 자주 발생했습니다. 특히 인증 로직이나 역할 기반 UI처럼 복잡한 로직은 단위 테스트가 필수적인데, 일정에 쫓겨 생략한 것이 아쉬웠습니다. 다음에는 최소한 핵심 비즈니스 로직에 대한 테스트 커버리지를 확보하여 안정성을 높이고 싶습니다. 또한 상태 관리를 Context API로만 처리하다 보니, 컴포넌트 깊이가 깊어지면서 prop drilling 이슈가 발생했습니다. Zustand나 Jotai 같은 가벼운 상태 관리 라이브러리를 도입했다면 코드가 더 간결하고 유지보수하기 쉬웠을 것입니다. 초기 컴포넌트 설계 시 재사용성을 충분히 고려하지 못해, 나중에 비슷한 컴포넌트를 여러 번 만들어야 했던 점도 개선이 필요합니다. 다음 프로젝트에서는 디자인 단계에서부터 컴포넌트 구조를 체계적으로 설계하고, 테스트와 상태 관리를 초기부터 고려하여 더 견고한 시스템을 구축하고 싶습니다."
      }
    },
    "dinoGo": {
      "title": "Dino Go",
      "subtitle": "Sui 블록체인 위치 기반 NFT 수집 게임",
      "role": "프론트엔드 개발",
      "teamSize": "4명",
      "duration": "2025.09.19 - 2025.09.21 (해커톤)",
      "overview": {
        "title": "프로젝트 개요",
        "background": "Dino Go는 3일간의 해커톤에서 진행한 Sui 블록체인 기반 위치 기반 NFT 수집 게임 프로젝트입니다. 사용자가 실제 위치를 이동하며 가상의 공룡 NFT를 수집하고, 수집한 NFT를 마켓플레이스에서 거래할 수 있는 게임입니다. Google Maps API와 Three.js를 결합하여 3D 맵 인터페이스를 구현했고, Walrus 분산 스토리지에 NFT 메타데이터를 저장하며, Seal 임계값 암호화로 데이터를 보호했습니다. 프론트엔드는 Next.js, TypeScript, Three.js, Tailwind CSS로 구성되었고, 백엔드는 Move 스마트 컨트랙트 4개 모듈과 Sui SDK 기반 Web3 통신 레이어로 이루어졌습니다.",
        "contribution": "4인 팀에서 프론트엔드 전체를 담당했으며, NFT Studio(민팅 인터페이스), Marketplace UI, 3D 맵 인터페이스를 포함한 10개 이상의 페이지를 구현했습니다. Google Maps API를 Three.js와 통합하여 지도 위에 3D 공룡 캐릭터와 인터랙티브 요소를 오버레이했고, 사용자가 지도를 드래그하거나 줌할 때도 3D 오브젝트가 정확한 위치에 렌더링되도록 좌표 변환 로직을 구현했습니다. NFT Studio에서는 사용자가 NFT를 민팅하고 Walrus에 메타데이터를 업로드할 수 있는 UI를 제공했으며, Marketplace에서는 NFT 목록 조회, 검색, 필터링, 거래 기능을 구현했습니다. Sui SDK, Walrus, Seal, Kiosk SDK를 통합하는 3개의 커스텀 Web3 클라이언트 라이브러리를 개발하여, 프론트엔드에서 블록체인 및 분산 스토리지와의 통신을 추상화했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "Google Maps + Three.js 3D 맵 통합",
          "problem": "Google Maps API는 2D 지도 렌더링에 최적화되어 있고, Three.js는 WebGL 기반 3D 그래픽 라이브러리입니다. 두 라이브러리를 결합하여 Google Maps 위에 3D 공룡 캐릭터와 인터랙티브 요소를 오버레이하는 것은 기술적으로 도전적이었습니다. Google Maps의 지도 타일 위에 Three.js의 WebGL 캔버스를 정확히 정렬해야 했고, 사용자가 지도를 드래그하거나 줌할 때 3D 오브젝트도 동기화되어 움직여야 했습니다. 또한 위도/경도 좌표를 Three.js의 3D 공간 좌표로 변환하는 수학적 계산이 필요했고, 모바일 환경에서도 부드럽게 렌더링되도록 성능 최적화가 필수였습니다.",
          "solution": "Google Maps의 OverlayView API를 활용하여 커스텀 오버레이를 생성하고, 그 안에 Three.js의 WebGLRenderer 캔버스를 삽입했습니다. OverlayView의 draw() 메서드를 오버라이드하여 지도가 움직일 때마다 Three.js 카메라의 위치와 회전을 업데이트하도록 구현했습니다. 위도/경도 좌표는 Google Maps의 Projection 객체를 사용해 픽셀 좌표로 변환한 뒤, Three.js의 월드 좌표 시스템에 매핑했습니다. 3D 공룡 모델은 glTF 형식으로 로드하고, 각 공룡의 위치 정보(위도/경도)를 기반으로 지도 위 적절한 위치에 렌더링했습니다. 성능 최적화를 위해 뷰포트 밖의 오브젝트는 컬링(culling)하여 렌더링하지 않도록 했고, LOD(Level of Detail) 기법으로 거리에 따라 모델의 디테일을 조절했습니다.",
          "result": "Google Maps 위에 3D 공룡 캐릭터가 자연스럽게 오버레이되어, 사용자는 실제 지도를 탐색하며 가상의 공룡을 발견하는 경험을 할 수 있었습니다. 지도를 드래그하거나 줌할 때도 3D 오브젝트가 정확한 위치에 동기화되어 렌더링되었고, 모바일 환경에서도 30fps 이상의 부드러운 프레임률을 유지할 수 있었습니다. 이 독특한 UX는 해커톤 심사에서 '혁신적인 사용자 경험'으로 높은 평가를 받았습니다."
        },
        "feature2": {
          "title": "NFT Studio 및 Marketplace UI",
          "problem": "사용자가 NFT를 민팅하고 거래할 수 있는 인터페이스가 필요했습니다. NFT 민팅 과정은 복잡한데, 사용자가 이미지를 업로드하면 Walrus 분산 스토리지에 저장하고, 메타데이터를 생성하여 Sui 블록체인에 기록해야 했습니다. Marketplace에서는 민팅된 NFT 목록을 조회하고, 검색 및 필터링 기능을 제공하며, 사용자가 NFT를 구매하거나 판매할 수 있는 거래 UI를 구현해야 했습니다. 블록체인 트랜잭션은 비동기적이고 시간이 걸리기 때문에, 사용자에게 명확한 진행 상태 피드백을 제공하는 것도 중요했습니다.",
          "solution": "NFT Studio에서는 React Hook Form을 활용한 다단계 폼을 구현하여, 사용자가 NFT 이름, 설명, 이미지를 입력하도록 했습니다. 이미지는 클라이언트 사이드에서 리사이징한 뒤 Walrus API를 통해 업로드하고, 반환된 해시를 메타데이터에 포함시켰습니다. Sui SDK를 사용해 Move 스마트 컨트랙트의 mint 함수를 호출하여 NFT를 민팅했고, 트랜잭션 진행 상태를 실시간으로 UI에 표시했습니다(Pending → Confirming → Success). Marketplace UI는 TanStack Table을 활용해 NFT 목록을 그리드로 표시하고, 검색 바와 필터(가격 범위, 희귀도 등)를 제공했습니다. NFT 카드를 클릭하면 상세 정보 모달이 열리고, '구매하기' 버튼을 누르면 Kiosk SDK를 통해 거래 트랜잭션을 생성하여 블록체인에 전송했습니다. 거래 완료 후에는 사용자의 NFT 소유권이 업데이트되도록 UI를 자동 새로고침했습니다.",
          "result": "사용자는 직관적인 UI로 NFT를 쉽게 민팅하고 거래할 수 있었습니다. Walrus 분산 스토리지 덕분에 NFT 이미지가 안전하게 저장되었고, 블록체인에 기록된 메타데이터로 소유권이 투명하게 관리되었습니다. Marketplace의 검색 및 필터 기능 덕분에 사용자는 원하는 NFT를 빠르게 찾을 수 있었고, 실시간 트랜잭션 상태 피드백으로 사용자 경험이 크게 향상되었습니다. 해커톤 데모에서 심사위원들이 실제로 NFT를 민팅하고 거래해보며 '완성도 높은 UI'라는 평가를 받았습니다."
        },
        "feature3": {
          "title": "Web3 클라이언트 라이브러리 개발",
          "problem": "프론트엔드에서 Sui SDK, Walrus, Seal, Kiosk SDK를 직접 사용하면 코드가 복잡해지고, 블록체인 통신 로직이 UI 컴포넌트와 뒤섞여 유지보수가 어려워집니다. 각 SDK마다 사용법이 다르고, 에러 처리와 재시도 로직도 일관되지 않아, 프론트엔드 개발자가 블록체인 세부 사항을 모두 이해해야 하는 부담이 있었습니다. 또한 여러 페이지에서 동일한 블록체인 호출 로직이 중복되어, 변경 사항이 생기면 여러 곳을 수정해야 했습니다. 블록체인과 분산 스토리지 통신을 추상화한 클라이언트 라이브러리가 필요했습니다.",
          "solution": "Sui SDK, Walrus, Seal을 각각 래핑한 3개의 커스텀 클라이언트 라이브러리를 개발했습니다. SuiClient는 Sui 블록체인과의 통신을 추상화하여, mintNFT(), transferNFT(), getNFTsByOwner() 같은 고수준 메서드를 제공했습니다. WalrusClient는 파일 업로드와 다운로드를 간단한 인터페이스로 래핑하여, uploadImage(file)만 호출하면 자동으로 리사이징, 업로드, 해시 반환을 처리했습니다. SealClient는 임계값 암호화를 활용해 민감한 메타데이터를 암호화하고 복호화하는 기능을 제공했습니다. 각 클라이언트는 에러 핸들링과 재시도 로직을 내장하여, 네트워크 실패 시 자동으로 재시도하도록 구성했습니다. TypeScript로 작성하여 타입 안정성을 확보했고, 모든 메서드는 Promise 기반 비동기 API로 통일했습니다.",
          "result": "프론트엔드 컴포넌트에서 블록체인 로직을 직접 다루지 않고, 간단한 클라이언트 메서드만 호출하면 되어 코드가 훨씬 간결하고 읽기 쉬워졌습니다. 블록체인 통신 로직이 중앙화되어, SDK 버전 업데이트나 에러 처리 개선이 필요할 때 클라이언트 라이브러리만 수정하면 모든 페이지에 자동 반영되었습니다. 타입 안정성 덕분에 컴파일 타임에 에러를 잡을 수 있었고, 팀원들도 블록체인 세부 사항을 몰라도 클라이언트 인터페이스만 보고 쉽게 개발할 수 있었습니다. 이 추상화 덕분에 3일이라는 짧은 해커톤 기간에도 안정적인 Web3 기능을 구현할 수 있었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "Three.js와 Google Maps 통합 시 렌더링 충돌 이슈",
          "problem": "Google Maps의 지도 타일 렌더링과 Three.js의 WebGL 렌더링이 동시에 실행되면서, 두 렌더러가 서로 충돌하여 지도가 깜빡이거나 3D 오브젝트가 사라지는 현상이 발생했습니다. 특히 사용자가 지도를 빠르게 드래그하거나 줌할 때 렌더링 프레임이 뒤섞여 시각적 버그가 자주 관찰되었습니다. Google Maps의 이벤트 루프와 Three.js의 렌더링 루프가 독립적으로 동작하다 보니, 동기화가 어려웠고, 어느 시점에 Three.js를 업데이트해야 하는지 명확하지 않았습니다. 또한 모바일 환경에서는 성능 저하로 인해 프레임률이 급격히 떨어지는 문제도 있었습니다.",
          "solution": "Google Maps의 idle 이벤트를 활용하여 지도 움직임이 완전히 멈춘 후에만 Three.js를 업데이트하도록 변경했습니다. 이를 통해 사용자가 지도를 드래그하는 동안에는 3D 렌더링을 일시 중지하고, 드래그가 끝나면 최종 위치에서 3D 오브젝트를 다시 렌더링하는 방식으로 충돌을 방지했습니다. 또한 requestAnimationFrame을 활용해 Three.js 렌더링 루프를 브라우저의 리페인트 주기와 동기화하여 부드러운 애니메이션을 유지했습니다. 모바일 성능 최적화를 위해 3D 모델의 폴리곤 수를 줄이고, 텍스처 해상도를 낮추며, 뷰포트 밖의 오브젝트는 렌더링하지 않도록 프러스텀 컬링(Frustum Culling)을 적용했습니다. 디바이스 성능에 따라 렌더링 품질을 자동 조절하는 적응형 품질 설정도 추가했습니다.",
          "result": "렌더링 충돌 문제가 해결되어 지도와 3D 오브젝트가 안정적으로 함께 렌더링되었습니다. 사용자가 지도를 조작할 때도 시각적 버그 없이 부드러운 경험을 제공할 수 있었고, 모바일 환경에서도 허용 가능한 프레임률을 유지하여 사용성이 크게 개선되었습니다. 해커톤 데모에서 다양한 디바이스로 테스트했을 때 모두 안정적으로 동작하여 심사위원들에게 긍정적인 평가를 받았습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "3일간의 해커톤이라는 극한의 시간 제약 속에서 프론트엔드 전체를 개발하며, 빠른 의사결정과 우선순위 설정의 중요성을 체감했습니다. Three.js를 활용한 3D 그래픽스 구현과 Google Maps API 통합 경험을 통해 WebGL 렌더링과 지도 서비스를 결합하는 독특한 기술 스택을 다뤄볼 수 있었고, Web3 기술 스택(Sui SDK, Move, Walrus, Seal)을 실전에서 활용하며 블록체인 프론트엔드 개발 역량을 쌓았습니다. 특히 커스텀 Web3 클라이언트 라이브러리를 설계하고 구현하면서, 복잡한 외부 SDK를 추상화하여 프론트엔드 개발자 친화적인 인터페이스로 만드는 아키텍처 설계 능력을 키울 수 있었습니다. Google Maps와 Three.js 통합 과정에서 두 렌더링 시스템을 동기화하는 문제를 해결하며, 저수준 렌더링 최적화와 성능 튜닝 경험도 얻었습니다. 해커톤 특유의 빠른 개발 속도 속에서도 기능을 완성하고 데모할 수 있었던 것은, 명확한 우선순위 설정과 팀원 간의 원활한 협업 덕분이었습니다.",
        "improvement": "3일의 제한된 시간으로 인해 코드 품질을 타협할 수밖에 없었습니다. 테스트 코드는 전혀 작성하지 못했고, 에러 핸들링도 최소한만 구현하여 엣지 케이스에서 버그가 발생할 가능성이 높습니다. 만약 프로덕션 환경으로 발전시킨다면, 철저한 리팩토링과 테스트 커버리지 확보가 필수적입니다. 모바일 최적화도 미흡했습니다. Three.js 렌더링이 모바일에서 배터리를 많이 소모하고 발열이 발생하는 문제가 있었는데, 시간 부족으로 근본적인 최적화를 하지 못했습니다. 향후에는 WebGL 렌더링 빈도를 줄이거나, 모바일에서는 3D 효과를 축소하는 등의 최적화가 필요합니다. Three.js 성능 최적화 여지도 많습니다. 모델 압축, 텍스처 아틀라스, 인스턴싱 등 고급 최적화 기법을 적용하면 성능을 더 향상시킬 수 있을 것입니다. 해커톤 경험을 통해 '빠르게 프로토타입을 만드는 것'과 '안정적인 프로덕션 코드를 작성하는 것'의 차이를 명확히 이해하게 되었고, 향후 프로젝트에서는 초기 설계에 더 많은 시간을 투자하여 견고한 기반을 다지고 싶습니다."
      }
    },
    "artWar": {
      "title": "Ministry of Truth",
      "subtitle": "AI 자율 에이전트 그림 경연 토너먼트 플랫폼",
      "role": "풀스택 개발",
      "teamSize": "4명 (기획 2, 개발 2)",
      "duration": "2026.02.09 - 2026.02.16 (해커톤)",
      "overview": {
        "title": "프로젝트 개요",
        "background": "Ministry of Truth는 Moltiverse Hackathon의 Agent+Token Track에서 1주간 진행한 프로젝트로, AI 에이전트들이 자율적으로 참여하는 그림 경연 토너먼트 플랫폼입니다. MC(사회자) 에이전트가 토너먼트를 진행하고, AI 아티스트들이 주제에 맞는 그림을 제출하면, AI 심사위원 2명이 채점하고, 관중(사용자)은 Monad 블록체인 위에서 승자를 예측하여 베팅합니다. nad.fun에 직접 $MOT 토큰을 발행하여 프로젝트 토큰 이코노미를 구성했습니다. 8강→4강→결승 토너먼트 구조로 시즌이 진행되며, 모든 상태 전환은 에이전트가 자율적으로 수행합니다. 백엔드는 NestJS + TypeORM + Supabase PostgreSQL, 프론트엔드는 Next.js, 에이전트는 OpenClaw 프레임워크 기반으로 AWS EC2에서 운영됩니다.",
        "contribution": "4인 팀에서 개발 2명 중 한 명으로 풀스택 개발을 담당했습니다. NestJS 백엔드 API 설계 및 구현(토너먼트 상태 머신, 베팅 시스템, 심사 시스템), Next.js 프론트엔드 5개 페이지(Home, Chamber, Betting, Leaderboard, Admin) 구현, Solidity 스마트 컨트랙트(MOTBetting.sol) 개발 및 Monad 메인넷 배포, nad.fun에서 $MOT 토큰 직접 발행, OpenClaw 에이전트 3종(MC, Judge A, Judge B)의 행동 규칙 설계 및 EC2 배포·운영까지 전반적인 개발을 수행했습니다."
      },
      "implementation": {
        "title": "기술 구현",
        "feature1": {
          "title": "자율 에이전트 오케스트레이션 (OpenClaw + EC2 + Polling)",
          "problem": "AI 에이전트 3종(MC 사회자, Judge A 미적 심사, Judge B 논리 심사)이 사람의 개입 없이 토너먼트를 자율적으로 운영해야 했습니다. 크론잡이 아닌 에이전트 자체가 상태를 인식하고 적절한 행동을 선택해야 하며, 에이전트가 크래시되어도 복구 가능해야 했습니다. OpenClaw 프레임워크는 heartbeat 기반으로 동작하는데, 이를 토너먼트 상태 머신과 어떻게 연동할지가 핵심 과제였습니다.",
          "solution": "각 에이전트에 AGENTS.md(행동 규칙), SOUL.md(페르소나), HEARTBEAT.md(헬스체크), skill.md(API 레퍼런스)를 작성하여 OpenClaw에 등록했습니다. MC 에이전트는 2분마다 heartbeat로 깨어나 현재 라운드 상태를 API로 조회하고, deadline 기반으로 상태 전환(created→submission→betting→judging→results→completed→advance)을 수행합니다. Judge A/B는 judging 상태일 때만 활성화되어 채점 API를 호출하며, 멱등성(idempotent) 처리로 중복 채점을 방지했습니다. 모든 에이전트는 AWS EC2에서 운영되며, 크래시 시 마지막 상태부터 재개할 수 있도록 설계했습니다.",
          "result": "사람의 개입 없이 AI 에이전트만으로 8강→4강→결승 토너먼트 전체 흐름이 자동 진행되었습니다. MC 에이전트의 polling 기반 상태 전환이 안정적으로 동작했고, Judge의 멱등성 처리 덕분에 에이전트가 재시작되어도 중복 없이 채점이 완료되었습니다. 해커톤 데모에서 실시간으로 토너먼트가 진행되는 모습을 보여줄 수 있었습니다."
        },
        "feature2": {
          "title": "토너먼트 상태 머신 (6단계 라운드 생명주기)",
          "problem": "토너먼트 라운드는 created→submission→betting→judging→results→completed의 6단계 생명주기를 가지며, 각 단계마다 허용되는 행동과 전환 조건이 다릅니다. submission 단계에서는 아티스트만 작품을 제출할 수 있고, betting 단계에서는 사용자만 베팅할 수 있으며, judging 단계에서는 심사위원만 채점할 수 있습니다. 잘못된 상태에서의 행동을 차단하고, 상태 전환의 유효성을 검증하며, 8강→4강→결승으로 이어지는 대진표 관리까지 구현해야 했습니다.",
          "solution": "NestJS 백엔드에서 라운드 상태를 enum으로 관리하고, 각 API 엔드포인트에 현재 상태를 검증하는 가드를 추가했습니다. 상태 전환 API(/rounds/:id/transition)는 MC 에이전트만 호출할 수 있도록 역할 기반 인증을 적용했고, 유효하지 않은 상태 전환(예: created에서 바로 judging으로)은 거부합니다. 대진표는 시즌 시작 시 8명 아티스트를 시드 배정하여 자동 생성하고, 라운드가 completed되면 승자를 다음 라운드로 advance시키는 로직을 구현했습니다. Supabase PostgreSQL에 rounds, matches, tournament_brackets, submissions, judge_results 등 12개 테이블로 데이터를 관리합니다.",
          "result": "6단계 상태 머신이 안정적으로 동작하며, 잘못된 상태에서의 API 호출을 차단하여 데이터 정합성을 보장했습니다. 8강부터 결승까지의 대진표가 자동으로 관리되어, MC 에이전트가 advance 명령만 내리면 다음 라운드가 준비되었습니다. 프론트엔드의 Chamber 페이지에서 실시간 대진표와 현재 라운드 상태를 시각적으로 확인할 수 있었습니다."
        },
        "feature3": {
          "title": "Monad 블록체인 베팅 시스템 (Solidity + nad.fun)",
          "problem": "사용자가 토너먼트 매치의 승자를 예측하여 MON(Monad 네이티브 토큰)으로 베팅하는 시스템이 필요했습니다. Monad는 EVM 호환 체인이지만 새로운 L1으로 문서와 레퍼런스가 부족했고, nad.fun 토큰 생태계와의 연동도 처음이었습니다. 스마트 컨트랙트에서 베팅 풀을 관리하고, 결과에 따라 배당금을 분배하며, 프론트엔드에서 지갑 연결 후 베팅 트랜잭션을 생성하는 전체 플로우를 구현해야 했습니다.",
          "solution": "Solidity로 MOTBetting.sol 스마트 컨트랙트를 작성하여 Monad 메인넷(Chain ID 143)에 배포했습니다. 컨트랙트는 매치별 베팅 풀 관리, 베팅 수락/마감, 결과에 따른 배당금 계산 및 분배 기능을 포함합니다. 프론트엔드 Betting 페이지에서는 사용자가 지갑을 연결하고, 매치별로 승자를 선택하여 MON을 베팅할 수 있는 UI를 구현했습니다. 백엔드에서는 라운드 결과가 확정되면 스마트 컨트랙트와 동기화하여 배당금 분배를 트리거합니다. nad.fun에 직접 $MOT 토큰을 발행하여 프로젝트의 토큰 이코노미를 구성했습니다.",
          "result": "Monad 메인넷 위에서 실제 MON으로 베팅이 가능한 시스템이 구축되었습니다. 스마트 컨트랙트의 투명한 베팅 풀 관리로 사용자 신뢰를 확보했고, 프론트엔드에서 원클릭 베팅 경험을 제공했습니다. nad.fun에 직접 발행한 $MOT 토큰과 연계하여 토너먼트 생태계의 토큰 이코노미를 구축할 수 있었습니다."
        }
      },
      "troubleshooting": {
        "title": "트러블슈팅",
        "issue1": {
          "title": "Monad/nad.fun 생태계 이해 — 새로운 체인의 레퍼런스 부족",
          "problem": "Monad는 새로운 EVM 호환 L1 블록체인으로, Ethereum과 동일한 Solidity를 사용할 수 있지만 RPC 엔드포인트, 가스 모델, 블록 생성 속도 등 체인 고유의 특성이 달랐습니다. 공식 문서가 부족하고, nad.fun 토큰 플랫폼과의 연동 사례도 거의 없어 개발 초기에 많은 시행착오를 겪었습니다. 특히 Hardhat으로 Monad 메인넷에 컨트랙트를 배포하는 과정에서 네트워크 설정과 가스 파라미터 조정에 어려움이 있었습니다.",
          "solution": "Monad 공식 Discord와 GitHub를 통해 최신 RPC URL(https://rpc.monad.xyz)과 Chain ID(143)를 확인했습니다. Hardhat 네트워크 설정에 Monad 메인넷을 추가하고, 가스 파라미터는 실제 트랜잭션을 보내며 최적값을 테스트했습니다. nad.fun API는 직접 분석하여 토큰 발행 플로우를 파악했고, 프론트엔드에서 MetaMask 커스텀 네트워크 추가 기능을 구현하여 사용자가 쉽게 Monad 네트워크에 연결할 수 있도록 했습니다.",
          "result": "새로운 블록체인 생태계에 성공적으로 적응하여 Monad 메인넷에 스마트 컨트랙트를 배포하고, nad.fun과 연동한 토큰 이코노미를 구축할 수 있었습니다. 문서가 부족한 환경에서도 커뮤니티와 직접 테스트를 통해 문제를 해결하는 경험을 쌓았습니다."
        },
        "issue2": {
          "title": "OpenClaw 에이전트 운용 — EC2 다수 에이전트 관리",
          "problem": "하나의 EC2 인스턴스에서 MC, Judge A, Judge B 3개의 OpenClaw 에이전트를 동시에 운영해야 했습니다. 각 에이전트는 독립적인 heartbeat 주기로 동작하며, 서로 다른 API 키와 역할을 가지고 있습니다. 에이전트가 예기치 않게 중단되거나 메모리를 과도하게 사용하는 경우, 다른 에이전트에 영향을 주지 않도록 격리가 필요했습니다. 또한 에이전트 로그를 모니터링하고, 상태를 실시간으로 확인할 수 있는 방법도 필요했습니다.",
          "solution": "각 에이전트를 개별 프로세스로 실행하고, systemd 서비스로 등록하여 자동 재시작을 설정했습니다. 에이전트별 로그를 분리하여 디버깅을 용이하게 하고, 백엔드에 /agents/health API를 구현하여 에이전트의 마지막 heartbeat 시간과 상태를 모니터링할 수 있도록 했습니다. Admin 페이지에서는 에이전트 상태를 실시간으로 확인하고, 필요시 라운드를 수동으로 제어할 수 있는 관리 인터페이스를 구현했습니다. 에이전트 행동 규칙(AGENTS.md)에 에러 복구 절차를 명시하여, 크래시 후 재시작 시 마지막 상태부터 안전하게 재개할 수 있도록 설계했습니다.",
          "result": "3개 에이전트가 하나의 EC2에서 안정적으로 동시 운영되었고, 에이전트 크래시 시 systemd가 자동으로 재시작하여 다운타임을 최소화했습니다. Admin 페이지에서 에이전트 상태를 실시간으로 모니터링하며, 해커톤 기간 중 발생한 이슈를 빠르게 대응할 수 있었습니다."
        }
      },
      "retrospective": {
        "title": "회고",
        "growth": "1주일이라는 해커톤 기간 동안 AI 자율 에이전트가 운영하는 온체인 토너먼트 플랫폼을 처음부터 끝까지 구축하며, 여러 도메인을 관통하는 풀스택 아키텍처 설계 역량을 크게 성장시켰습니다. OpenClaw 프레임워크로 AI 에이전트의 행동 규칙을 설계하고 자율 운영되도록 하는 경험은 기존 웹 개발과는 전혀 다른 패러다임이었으며, '에이전트가 스스로 판단하고 행동하는 시스템'을 설계하는 관점을 배울 수 있었습니다. Monad라는 새로운 블록체인 생태계에서 스마트 컨트랙트를 배포하고 nad.fun 토큰과 연동하며, 문서가 부족한 환경에서 빠르게 적응하는 능력도 길렀습니다. NestJS 백엔드, Next.js 프론트엔드, Solidity 스마트 컨트랙트, OpenClaw 에이전트를 하나의 시스템으로 통합하는 과정에서 각 기술 스택 간의 인터페이스 설계와 데이터 흐름 관리 역량이 향상되었습니다.",
        "improvement": "1주일의 제한된 시간으로 인해 테스트 코드가 부족했고, 에이전트 행동의 엣지 케이스 처리가 미흡했습니다. 특히 에이전트가 예상치 못한 API 응답을 받았을 때의 복구 로직이 불완전하여, 해커톤 기간 중 수동으로 개입해야 하는 상황이 발생했습니다. 또한 프론트엔드 UI/UX에 충분한 시간을 투자하지 못해, 디자인 완성도가 아쉬웠습니다. 향후 유사한 프로젝트에서는 에이전트의 에러 복구 시나리오를 더 꼼꼼히 설계하고, 프론트엔드와 에이전트 시스템 각각에 대한 통합 테스트를 작성하여 안정성을 높이고 싶습니다."
      }
    }
  }
}
