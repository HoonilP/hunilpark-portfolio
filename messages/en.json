{
  "Home": {
    "title": "Hunil Park",
    "subtitle": "Frontend Developer",
    "description": "Crafting clean and refined web experiences",
    "comingSoon": "More sections coming soon"
  },
  "Navigation": {
    "home": "Home",
    "about": "About",
    "skills": "Skills",
    "projects": "Projects",
    "experience": "Experience",
    "education": "Education",
    "contact": "Contact"
  },
  "Common": {
    "language": "KO",
    "languageLabel": "Switch to Korean"
  },
  "Footer": {
    "email": "Email",
    "github": "GitHub",
    "velog": "Velog",
    "copyright": "Hunil Park. All rights reserved."
  },
  "Hero": {
    "name": "Hunil Park",
    "title": "Frontend Developer",
    "intro": "Crafting clean and refined web experiences",
    "resumeLink": "View Resume"
  },
  "About": {
    "sectionTitle": "About",
    "paragraph1": "I'm a frontend developer who designs and implements user-centric web interfaces. With hands-on experience building dashboards and management systems using React, Next.js, and TypeScript, I focus on translating complex business logic into intuitive UIs.",
    "paragraph2": "Having lived and worked in France, Myanmar, and Malaysia, I bring cross-cultural collaboration skills to every project. With strong English proficiency (TOEIC 930) and business-level French, I communicate effectively in global team settings."
  },
  "Contact": {
    "sectionTitle": "Contact",
    "description": "Interested in working together? Feel free to reach out.",
    "email": "Email",
    "phone": "Phone",
    "github": "GitHub",
    "velog": "Velog"
  },
  "Skills": {
    "sectionTitle": "Tech Stack",
    "frontend": "Frontend",
    "backend": "Backend",
    "devops": "DevOps",
    "database": "Database"
  },
  "Projects": {
    "sectionTitle": "Projects",
    "viewDetails": "View Details",
    "joshua": {
      "title": "Joshua AI Agent",
      "description": "AI copywriting agent powered by KoGPT-2. Built a cross-platform desktop app with Electron and Angular, integrated Stripe payments.",
      "period": "Jun 2022 - Mar 2023"
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "description": "Customer management system built with Next.js and NestJS. Implemented an admin dashboard and automated ~90% of accounting processes.",
      "period": "Jul 2024 - Jun 2025"
    },
    "retailAnalysis": {
      "title": "Retail Store Customer Analysis",
      "description": "Visual intelligence system using YOLO for in-store customer tracking, with a VanillaJS dashboard for analytics visualization.",
      "period": "Nov 2022 - Apr 2023"
    }
  },
  "Experience": {
    "sectionTitle": "Experience",
    "dyCms": {
      "date": "Jul 2024 - Jun 2025",
      "title": "DY Microfinance — CMS Development",
      "company": "DY Microfinance (Myanmar)",
      "description": "Developed a customer management system with a separated frontend-backend architecture using Next.js, NestJS, and PostgreSQL. Built an admin dashboard and automated ~90% of accounting processes."
    },
    "paymentInApp": {
      "date": "May 2022 - Mar 2024",
      "title": "Payment In-App Inc. — Business Planning Lead",
      "company": "Payment In-App Inc.",
      "description": "Led planning and execution of multiple projects including Joshua AI Agent (Electron/Angular), manufacturing defect detection (YOLO), retail customer behavior analysis (VanillaJS dashboard), and EMV Seoul transit feasibility study."
    },
    "dyAccounting": {
      "date": "Jan 2017 - Dec 2018",
      "title": "DY Microfinance — Accounting & Finance Operations",
      "company": "DY Microfinance (Myanmar)",
      "description": "Managed accounting and finance operations with process automation. Built automated BS/PL generation spreadsheets to improve operational efficiency."
    }
  },
  "Education": {
    "sectionTitle": "Education",
    "sangmyung": {
      "date": "Mar 2024 - Feb 2026",
      "title": "Sangmyung University, Dept. of Big Data Convergence",
      "description": "Expected Graduation | GPA 4.33 / 4.5"
    },
    "yangon": {
      "date": "Jan 2017 - Dec 2018",
      "title": "Yangon University of Foreign Languages, Myanmar Studies",
      "description": "Withdrawn"
    },
    "certificationsTitle": "Certifications & Awards",
    "certifications": {
      "computerSkills": "Computer Skills Level 1 (Nov 2020)",
      "accounting": "Computerized Accounting Level 1 (Mar 2021)",
      "fsi": "FSI AIxData Challenge 2024 Excellence Award",
      "toeic": "TOEIC 930 (Nov 2025)"
    },
    "activitiesTitle": "Activities",
    "activities": {
      "bay": "Yonsei University Blockchain Society BAY, 17th Cohort",
      "aiCourse": "Youngwoo Global Learning AI S/W Expert Training (Apr 2022)"
    }
  },
  "ProjectDetail": {
    "sidebar": {
      "role": "Role",
      "teamSize": "Team Size",
      "duration": "Duration",
      "techStack": "Tech Stack",
      "links": "Links"
    },
    "joshua": {
      "title": "Joshua AI Agent",
      "subtitle": "AI Copywriting Agent powered by KoGPT-2",
      "role": "Frontend Development",
      "teamSize": "4 members",
      "duration": "Jun 2022 - Mar 2023",
      "overview": {
        "title": "Project Overview",
        "background": "Joshua AI Agent is an AI-powered copywriting service built on the KoGPT-2 language model. It's a subscription-based desktop application that generates marketing content and advertising copy, supporting both Windows and macOS through a cross-platform architecture. The project required integrating a FastAPI backend with PostgreSQL database for AI model serving, where I was responsible for the frontend development. The key technical challenges included integrating Angular framework within Electron environment, implementing real-time streaming rendering of AI responses, and adapting the Stripe payment flow for desktop application context.",
        "contribution": "I led all aspects of frontend development, from designing the Electron + Angular desktop application architecture to implementing the AI response interface and Stripe payment integration. I designed the IPC (Inter-Process Communication) structure between Electron's Main and Renderer processes, handling backend API communication in the Main process while keeping the Angular-based Renderer process focused purely on UI rendering and user interaction. For progressive streaming display of AI-generated content, I built an asynchronous data processing pipeline using RxJS. I also customized Stripe's Checkout session-based payment flow to fit the desktop environment."
      },
      "implementation": {
        "title": "Technical Implementation",
        "feature1": {
          "title": "Electron + Angular Cross-Platform Desktop App Architecture",
          "problem": "Electron is typically paired with React or Vue, and integration examples with Angular were relatively scarce. I needed to harmoniously configure Angular's complex build setup (Webpack, TypeScript compiler) with Electron's Main/Renderer process structure, creating a build pipeline that worked reliably in both development and production environments. Setting up an HMR (Hot Module Replacement) environment that connects Angular's dev server with Electron processes was the core challenge.",
          "solution": "I built a build workflow using Electron Builder to package the Angular application into the Electron environment. The Main process was written in pure TypeScript to handle native functionality and system-level logic like BrowserWindow creation, IPC handler registration, and backend API communication. The Renderer process was configured to load the Angular CLI build output. In development mode, Electron loads the Angular dev server (localhost:4200), while in production builds it loads static files from the dist folder via file:// protocol. I designed IPC communication using ipcRenderer and ipcMain in a request-response pattern, maintaining a unidirectional data flow where user input from the Renderer triggers backend API calls through the Main process, with responses flowing back to the Renderer.",
          "result": "I successfully shipped a cross-platform desktop app that runs reliably on both Windows and macOS. In development, Angular's HMR enables fast development cycles, while production builds create single executable files (Windows: .exe, macOS: .dmg). The IPC communication layer allowed backend API changes to be isolated to the Main process, keeping coupling with Angular component code low."
        },
        "feature2": {
          "title": "Real-Time Streaming Rendering Interface for AI Responses",
          "problem": "The way we presented KoGPT-2 generated text to users was crucial. Displaying long copy all at once meant users received no feedback during wait time, degrading UX. Conversely, streaming the text token by token gave users a sense of 'generation in progress,' making perceived latency feel faster. When the backend sends responses via Server-Sent Events (SSE) or chunked format, the frontend needed to receive and render this data in real-time. I needed an efficient way to handle asynchronous stream data in Angular while smoothly updating the UI.",
          "solution": "I built an Observable-based asynchronous processing pipeline using RxJS. When the Main process receives streaming responses from the backend API via Electron IPC, it forwards each chunk as events to the Renderer process. Angular components subscribe to these events as Observables and reflect them on screen. Specifically, I used fetch API's ReadableStream to read backend responses, parsed each chunk, and transmitted it to the Renderer via ipcRenderer.send. In Angular components, I converted IPC events to Observables using fromEvent, accumulated text using the scan operator, and bound it to templates via async pipe. This created a natural typing animation effect.",
          "result": "Users could see the AI generating copy in real-time, making wait times feel subjectively shorter and improving the app experience. The RxJS-based architecture allowed me to declaratively add error handling (catchError), timeouts (timeout), and retry logic (retry), enabling the frontend to handle unstable backend APIs gracefully. User feedback highlighted positive reactions like 'seeing the generation process is great.'"
        },
        "feature3": {
          "title": "Stripe Payment Integration and Subscription Management UI",
          "problem": "As a subscription-based product, integrating Stripe Checkout payment flow and subscription status management UI was essential. Unlike typical web apps, desktop apps require opening a browser separately for payment, then returning to the app after completion. I needed to create a Stripe Checkout Session, have payment completed in an external browser, then have the app detect payment completion and update the UI accordingly. I also needed a dashboard interface to clearly show users whether they're currently subscribed, in a free trial, or if payment failed.",
          "solution": "I configured Stripe Checkout's web-based payment page to open in the default browser using Electron's shell.openExternal API. When the backend creates a Stripe Checkout Session, the client receives the URL and launches the browser where users enter card information on Stripe's secure payment page. After payment completion, the backend updates user subscription status via Stripe Webhook. The app polls the backend API periodically (or when users click a 'payment complete' button) to fetch the latest subscription status and refresh the UI. I managed subscription information in an Angular service layer using BehaviorSubject so subscription status could be referenced app-wide in real-time, displaying information like subscription expiration date and next payment date on the dashboard.",
          "result": "I was able to provide a secure, standard Stripe payment flow even in a desktop app environment. Users experienced a natural flow where clicking the payment button in the app opens a browser for payment completion, then returns to the app. The subscription status management UI helped users clearly understand their current subscription plan and remaining time, significantly reducing customer support inquiries. The combination of Stripe Webhook and polling ensured reliable handling of payment completion events without missing any."
        }
      },
      "troubleshooting": {
        "title": "Troubleshooting",
        "issue1": {
          "title": "Large Data Transfer Errors in Electron IPC Communication",
          "problem": "When transferring long AI-generated text or large amounts of history data from the Main process to the Renderer process via IPC, intermittent errors occurred. Transmitting data beyond a certain size caused Electron to throw memory errors or blocked the IPC channel, freezing the app. Initially, I tried sending all data at once using ipcRenderer.send and ipcMain.on, but this created bottlenecks during serialization for large data.",
          "solution": "I switched to a streaming approach, splitting large data into chunks for multiple transmissions. I transitioned to a Promise-based IPC pattern using ipcRenderer.invoke and ipcMain.handle, dividing data into fixed-size chunks (e.g., 1MB) for sequential transmission, then assembling them on the Renderer side. I also optimized backend response structure to avoid sending unnecessary data, adopting a GraphQL-style query approach on the frontend to selectively receive only needed fields.",
          "result": "The system became stable even when transferring large data, eliminating IPC communication bottlenecks and significantly improving app responsiveness. Users could query long histories or batch-generate large amounts of copy without the app freezing, maintaining smooth operation."
        },
        "issue2": {
          "title": "Angular Zone.js and Electron Event Loop Conflicts",
          "problem": "Angular uses Zone.js for automatic change detection, but when Electron IPC events occur outside Angular's Zone, UI doesn't automatically update. Specifically, changing component state in event listeners registered with ipcRenderer.on didn't reflect on screen, requiring users to manually navigate to another screen and back to see updates. This problem arose from developing without understanding Zone.js's operation principles.",
          "solution": "I injected the NgZone service and explicitly called zone.run() within IPC event handlers to enter Angular's change detection cycle. I encapsulated all IPC event reception logic in Angular services, converted them to Observables using fromEvent, and ensured execution within Angular Zone using observeOn(asyncScheduler). This guaranteed automatic UI updates when IPC events occurred.",
          "result": "IPC event-based state changes were immediately reflected on screen, greatly improving user experience. I gained deep understanding of Zone.js operation principles and established best practices for event handling in Electron + Angular environments."
        }
      },
      "retrospective": {
        "title": "Retrospective",
        "growth": "Developing a cross-platform desktop application combining Electron and Angular deepened my understanding of architecture for building native apps with web technology stacks. I learned a great deal solving unique problems that arise when combining web frameworks with desktop environments, including IPC communication structure design, Main/Renderer process role separation, and Angular Zone.js interaction with Electron's event loop. Experience with RxJS-based asynchronous data streaming proved valuable in subsequent projects. Stripe payment integration gave me capabilities for implementing SaaS business model frontends. Implementing an interface that renders AI model responses in real-time streaming made me realize the importance of UX design that transforms 'waiting' into 'experiencing' beyond simply displaying data.",
        "improvement": "Early in the project, I struggled with limited references for Electron-Angular integration through much trial and error. More thorough technical validation (POC) upfront would have accelerated development. Insufficient test code for the IPC communication layer consumed considerable debugging time—systematic unit and integration tests for Main-Renderer communication logic would have improved stability. From a performance optimization perspective, more thorough bundle size optimization (tree-shaking, lazy loading) and memory profiling could have improved app launch speed and resource usage. In future similar projects, I plan to clearly establish testing strategy and performance goals during initial design, with continuous monitoring and improvement."
      }
    },
    "dyCms": {
      "title": "DY Microfinance CMS",
      "subtitle": "Customer Management System",
      "role": "Full-stack Development",
      "teamSize": "1 member (Solo)",
      "duration": "Jul 2024 - Jun 2025",
      "overview": {
        "title": "Project Overview",
        "background": "DY Microfinance CMS is a web-based management system designed to automate customer management and accounting operations for a Myanmar-based microfinance institution. Previously, customer information, loan records, and accounting ledgers were managed manually using Excel spreadsheets, leading to frequent data integrity issues and requiring dozens of hours of manual work during month-end closing. To address this, I adopted a separated architecture connecting a Next.js frontend with a NestJS backend via PostgreSQL database. As a solo developer handling both frontend and backend, I focused on admin dashboard UI/UX design and implementation, complex accounting data table management, and form validation logic on the frontend side.",
        "contribution": "I was responsible for the entire process from system architecture design to deployment. From a frontend perspective, I implemented an admin dashboard based on Next.js App Router, form processing using Server Actions, accounting data table rendering optimization, and bilingual support (Burmese/English). The dashboard visualizes key metrics like customer count, loan balance, and monthly revenue in real-time, enabling management to grasp the current situation at a glance. Through accounting process automation, I built an interface that auto-generates BS (Balance Sheet) and PL (Profit & Loss) statements, eliminating approximately 90% of manual work and reducing month-end closing time from dozens of hours to just a few hours. I also implemented Role-Based Access Control at the frontend routing level, ensuring users (loan officers, accounting staff, administrators) can only access screens and features relevant to their roles."
      },
      "implementation": {
        "title": "Technical Implementation",
        "feature1": {
          "title": "Next.js-Based Admin Dashboard Design and Implementation",
          "problem": "Accounting staff and administrators needed to check numerous pieces of information daily. I had to intuitively display various data on a single screen—customer count, loan balance, delinquency rate, monthly revenue, recent loan applications—while ensuring page loading speed remained fast despite real-time data updates. PostgreSQL aggregate queries could be time-consuming, requiring a strategy for how the frontend fetches and displays data. Additionally, considering Myanmar users' unstable internet environment, offline support and data caching were important requirements.",
          "solution": "I leveraged Next.js App Router's Server Components to optimize initial loading speed by fetching data on the server and including it in the HTML before transmission. Core metrics (customer count, loan balance, etc.) are pre-calculated values provided by the backend API, with the frontend simply displaying them. Complex aggregations use PostgreSQL Materialized Views, periodically refreshed on the backend. For chart rendering, I used Recharts library to visualize monthly revenue trends and loan repayment rates. For table components, I used TanStack Table to handle sorting, filtering, and pagination quickly on the client side. I also introduced React Query (TanStack Query) to cache API responses, using a stale-while-revalidate strategy to show cached data first when users revisit the dashboard, fetching fresh data in the background.",
          "result": "Admin dashboard initial loading time was reduced to under 3 seconds, allowing users to immediately see key metrics upon opening the page. React Query's caching reduced unnecessary API calls even with frequent dashboard visits, decreasing server load. Charts and tables rendered smoothly, increasing user satisfaction. Even in unstable internet environments, basic information remained accessible via cached data."
        },
        "feature2": {
          "title": "Separated Frontend-Backend Architecture and API Integration",
          "problem": "Initially, I debated whether to develop as a full-stack setup using Next.js API Routes or completely separate frontend and backend. Considering the possibility of adding mobile apps or other clients in the future, separating the backend as an independent API server was advantageous, but managing two projects as a solo developer was burdensome. I also needed an architecture that maintains type safety when calling backend APIs from the frontend, and consistently handles authentication token management and error handling.",
          "solution": "I separated the Next.js frontend and NestJS backend, but used Next.js's rewrites feature in development to proxy /api/* paths to the NestJS server, avoiding CORS issues. In production, I used Nginx as a reverse proxy to serve frontend and backend from the same domain. I created a custom axios-based API client instance that automatically includes JWT tokens in all requests, with interceptors that automatically attempt token refresh on 401 responses. For type safety, I shared DTOs (Data Transfer Objects) defined in NestJS backend with the frontend, enabling compile-time validation of API request/response structures through TypeScript type inference. I added runtime type validation using Zod, immediately throwing errors when backend responses differ from expectations for easier debugging.",
          "result": "Frontend and backend were clearly separated, enabling independent development and deployment. The NestJS backend functions as a RESTful API server, making future mobile app or external system integration straightforward. The Next.js frontend could focus purely on UI/UX. The type-sharing structure meant backend API changes immediately triggered frontend type errors, preventing runtime errors proactively. Automatic token refresh via axios interceptors prevented session expiration even during extended dashboard use, improving user experience."
        },
        "feature3": {
          "title": "Accounting Process Automation Interface Implementation",
          "problem": "The existing accounting process involved manually entering loan records, repayment records, and expense data into Excel, then manually creating BS and PL statements at month-end. Automating this required providing forms on the frontend to input loan/repayment/expense data, performing accounting logic on the backend, then outputting results as reports on the frontend. Since accounting data integrity was critical, strict validation at the input stage was necessary, and UX-level guidance was needed to prevent users from entering incorrect data. Month-end reports also needed to be exportable as PDFs.",
          "solution": "I leveraged Next.js Server Actions to handle data validation and DB storage on the server side upon form submission. On the client side, I combined React Hook Form with Zod for real-time form validation, providing immediate feedback (error messages, success indicators) as users input fields. For example, loan amount fields accept only numbers, and repayment dates must be in the future relative to loan dates—validated on both client and server sides. For month-end report generation, when users click 'Generate Report,' the backend aggregates accounting data to create BS/PL statements. The frontend renders these as tables, then uses React-PDF library to convert to PDF on the client side for download. This simplified month-end closing to three steps: data input → button click → report download.",
          "result": "Accounting process automation reduced month-end closing time from dozens of hours to just a few, virtually eliminating manual errors (typos, calculation mistakes). Users received real-time error feedback during form input to correct invalid data beforehand. Instant PDF report generation for submission to management greatly improved work efficiency. Achieving approximately 90% automation dramatically reduced accounting staff workload and significantly improved data integrity."
        }
      },
      "troubleshooting": {
        "title": "Troubleshooting",
        "issue1": {
          "title": "Dashboard Table Rendering Performance Degradation",
          "problem": "As customer count grew to thousands, rendering the customer list table on the dashboard caused browser stuttering. Initially fetching all customer data from the backend at once for frontend rendering, thousands of rows took several seconds to draw in the DOM, with severe stuttering during scrolling. Users wanted to quickly scroll through tables to find specific customers, but rendering performance issues severely degraded usability.",
          "solution": "I introduced virtual scrolling techniques to optimize by rendering only rows visible in the current viewport to the DOM. Using TanStack Table's virtualization feature, even with thousands of data points, only 20-30 visible rows are actually rendered, with DOM dynamically replaced during scrolling. I also added server-side pagination as an optional feature, allowing users to fetch 50 items per page. I enhanced search filtering so users can filter by name or loan ID, fetching and rendering only matching data from the backend.",
          "result": "Table rendering performance improved dramatically, with initial loading completing in under 1 second even with thousands of customer records, and smooth scrolling. Users could quickly explore data, and virtual scrolling reduced memory usage, enabling stable operation even in low-spec environments."
        },
        "issue2": {
          "title": "Preventing Duplicate Form Submissions",
          "problem": "When users submitted loan application forms, clicking the button multiple times or slow network responses causing delays resulted in duplicate data being saved to the DB. In Myanmar's unstable internet environment, users frequently clicked the 'Submit' button again when nothing happened after the first click. This caused data integrity issues like the same loan application being created twice.",
          "solution": "On the frontend, I immediately disabled the submit button and displayed a loading indicator (spinner) upon form submission to clearly show users 'processing in progress.' Using React Hook Form's isSubmitting state, I prevented button clicks during submission. Upon Server Action completion, I displayed success or error messages for feedback. On the backend, I added idempotency handling with Redis-based duplicate request checking logic to process only the first request and ignore subsequent ones when identical requests arrive within a short time. I also applied the Optimistic UI pattern to update the UI immediately upon form submission, confirming after backend response for improved user experience.",
          "result": "Data integrity issues from duplicate requests were completely resolved. Users immediately received feedback after form submission, clearly recognizing 'processing in progress.' In slow network environments, users stopped clicking the button multiple times, reducing unnecessary requests and server load."
        }
      },
      "retrospective": {
        "title": "Retrospective",
        "growth": "As a solo full-stack developer designing and implementing both frontend and backend, I deepened my understanding of overall web application architecture. Particularly using Next.js App Router, Server Components, and Server Actions in production helped me experience the pros and cons of SSR and CSR firsthand, enabling me to judge which rendering strategy to choose in different situations. Configuring a separated frontend-backend architecture built practical skills essential for real-world work: API design, ensuring type safety, and handling authentication/authorization. Implementing dashboard and data visualization UI improved my UX design ability to translate complex business logic into user-friendly interfaces. Through accounting process automation, I experienced the value of development that creates 'business impact' beyond mere 'feature implementation,' finding great satisfaction in continuously improving based on user feedback.",
        "improvement": "Delaying test code writing early in the project led to occasional regression issues where new features broke existing ones. Especially for critical accuracy areas like accounting logic, unit and integration tests are essential—skipping them due to schedule pressure was regrettable. In the future, I want to adopt TDD (Test-Driven Development) or at least ensure test coverage for core business logic. CI/CD pipeline setup was also insufficient. Manual SSH deployment to servers could have been faster and more stable with automated deployment pipelines using GitHub Actions. For performance monitoring, introducing tools like Sentry or LogRocket to track production errors and performance bottlenecks in real-time would have enabled faster problem resolution. In my next project, I plan to establish testing, CI/CD, and monitoring from the start to build more stable and maintainable systems."
      }
    },
    "retailAnalysis": {
      "title": "Retail Store Customer Analysis",
      "subtitle": "Visual Intelligence-based Customer Tracking System",
      "role": "Data Visualization Development",
      "teamSize": "3 members",
      "duration": "Nov 2022 - Apr 2023",
      "overview": {
        "title": "Project Overview",
        "background": "A system deployed in retail stores in Malaysia that uses YOLO object detection models to track customer movement in real-time. It recognizes customer positions and movement paths from CCTV footage, collecting data on how long customers stay at which displays and what routes they take through the store. This enables store managers to understand customer behavior patterns and gain insights for optimizing display positioning and improving traffic flow. On the backend, a PyTorch-implemented YOLO model performs real-time video processing, while the frontend receives this data and visualizes it in dashboard form. For the frontend tech stack, VanillaJS (pure JavaScript) was deliberately chosen to validate whether complex real-time data visualization could be implemented without frameworks like React or Vue, and to optimize bundle size and performance.",
        "contribution": "I was responsible for all frontend data visualization aspects, building a real-time dashboard with VanillaJS. I implemented heatmap and movement tracking visualizations using Canvas API and SVG, receiving customer location data transmitted via WebSocket from the backend team. I displayed customers' current positions in real-time on the store floor plan, created heatmaps using color gradients to show customer density by time period, and connected individual customer movement paths with lines for tracking. I also implemented statistical charts (visitor count by time, dwell time by zone, etc.) using the Chart.js library. Since I had to perform state management and DOM manipulation without a framework, I designed simple state management patterns (Observer pattern) and component separation structure myself. I applied rendering optimizations (RequestAnimationFrame, Debouncing) to efficiently process incoming real-time data and implemented event listener cleanup logic to prevent memory leaks."
      },
      "implementation": {
        "title": "Technical Implementation",
        "feature1": {
          "title": "VanillaJS-Based Real-Time Data Visualization Dashboard",
          "problem": "I had to implement a complex real-time dashboard without frameworks like React or Vue. Without the convenience features frameworks provide—component structure, state management, virtual DOM—I needed to receive WebSocket data in pure JavaScript, render it in real-time to Canvas and SVG, and handle user interactions (zoom, pan, time filtering). Particularly when dozens of location data points arrive per second, directly manipulating the DOM could cause performance degradation, requiring efficient rendering strategies. I also needed to consider modularization and separation of concerns to prevent code from becoming spaghetti.",
          "solution": "I modularized code by functionality using ES6 Modules. I separated a DataService module for WebSocket communication, HeatmapRenderer module for Canvas rendering, PathRenderer module for SVG movement rendering, and ChartRenderer module for chart rendering. For state management, I implemented a simple Observer pattern where DataService sends notifications to registered renderers when receiving new data, prompting each to update. Canvas rendering used requestAnimationFrame to render in sync with browser repaint cycles for smooth animation, with conditions to redraw only when data changed to reduce unnecessary rendering. Heatmaps accumulated customer dwell time in 2D arrays, converted to color gradients and drawn on Canvas. SVG represented each customer's movement path as path elements, dynamically adding/removing them. User interactions (drag to move screen, mouse wheel to zoom) were handled by registering event listeners to manipulate Canvas transform.",
          "result": "I successfully implemented a stable, high-performance real-time dashboard without frameworks. Small bundle size (under 100KB excluding Chart.js) enabled very fast initial loading. Canvas-based rendering maintained 60fps even when simultaneously displaying hundreds of data points. Modularized code structure allowed independent development of new visualization features (e.g., displaying detailed information when clicking specific zones) without affecting other modules. Store managers could monitor customer movement in real-time and analyze time-based patterns to improve store layouts."
        },
        "feature2": {
          "title": "Canvas-Based Customer Movement Heatmap and Tracking UI",
          "problem": "I needed to intuitively represent customer movement on the store floor plan. With dozens of customers moving simultaneously, I needed visualization that displays each customer's position and movement path in real-time while allowing overall pattern understanding at a glance (which zones are popular, which routes are common). Heatmaps needed to express accumulated data over time with colors, while movement tracking needed to show individual customer paths with lines. Additionally, when users select time periods, only data from those periods should be filtered and displayed. Users also needed the ability to output month-end reports as PDFs.",
          "solution": "I used Canvas API to draw the store floor plan as background, then overlaid heatmap and movement layers. For heatmaps, I divided the store into a grid (e.g., 1m x 1m), accumulated customer dwell time in each grid cell, then expressed values with blue (low) → green (medium) → red (high) gradients. I used Canvas's fillRect and createLinearGradient for smooth color transitions. For movement tracking, I stored each customer's path in arrays and drew paths as lines using Canvas's lineTo and stroke. For time filtering, when users manipulate sliders, I filtered data to the selected time range and re-rendered heatmaps and movements. For performance with large datasets, I pre-calculated and cached all data, referencing cached data during filtering for quick rendering. I also added interaction where clicking specific zones displays detailed statistics (average dwell time, visitor count) in tooltips.",
          "result": "Store managers could visually understand 'which displays are most popular' and 'where blind spots customers rarely visit' through heatmaps. Movement tracking enabled analysis of 'what routes customers typically take from entrance' and 'whether paths to checkout are efficient.' Time filtering allowed comparison of time-based pattern differences like weekday mornings versus weekend evenings, informing adjustments to display positioning and promotion strategies. Canvas-based rendering performed smoothly without degradation even when simultaneously displaying hundreds of paths."
        }
      },
      "troubleshooting": {
        "title": "Troubleshooting",
        "issue1": {
          "title": "Memory Leaks During Real-Time Data Rendering",
          "problem": "Running the dashboard for extended periods caused browser memory usage to continuously increase, eventually slowing or crashing the browser. Initially, I continuously accumulated WebSocket incoming data in arrays and iterated through all data when rendering Canvas. Over time, array size grew, slowing rendering and consuming excessive memory. Event listeners not properly cleaned up also caused memory leaks.",
          "solution": "I modified data retention strategy to automatically delete data older than a certain time (e.g., 1 hour). I applied a Circular Buffer pattern to limit maximum data size, removing the oldest data when new data arrives. For rendering optimization, instead of redrawing all data every time, I introduced partial updates to redraw only changed portions. Event listeners were explicitly cleaned up by calling removeEventListener when components were removed (during page navigation). WebSocket connections were also terminated by calling close() when leaving the page. I used Chrome DevTools' Performance Monitor and Memory Profiler to find and fix memory leak points.",
          "result": "Memory leaks were resolved, enabling stable browser operation even when running the dashboard all day. Memory usage remained below a certain level, and rendering performance improved to maintain smooth animation during extended use. Store managers could keep the dashboard continuously running for real-time monitoring."
        },
        "issue2": {
          "title": "Increasing State Management Complexity in VanillaJS Environment",
          "problem": "Developing in pure JavaScript without frameworks caused increasingly complex state management. Multiple modules referencing and modifying the same data caused data synchronization issues, making it difficult to track which module changed data and hindering debugging. Particularly when users changed filters, multiple charts and heatmaps needed simultaneous updates. Manually calling each module made code complex and error-prone.",
          "solution": "I implemented a simple state management library myself. I created a central Store object based on the Observer pattern, where each module (renderers, charts) subscribes to the Store and receives automatic notifications when data changes. The Store manages state immutably, returning new objects on state changes, comparing with previous state to render only actually changed portions. State change logic was defined in an Actions object, structuring all state changes to occur through explicit actions. This implemented a Redux-like unidirectional data flow in VanillaJS. For debugging, I added middleware to log state change history to the console.",
          "result": "State management became clear and predictable. When data changes occurred, all subscribed modules automatically updated, eliminating the need to manually call each module. When bugs occurred, I could quickly identify causes by tracking state change history. When adding new features, I only needed to subscribe new modules without modifying existing code, greatly improving maintainability. I proved that complex state management is possible even with VanillaJS, but simultaneously experienced the value frameworks like React or Vue provide (component structure, virtual DOM, developer tools)."
        }
      },
      "retrospective": {
        "title": "Retrospective",
        "growth": "Implementing a complex real-time dashboard without frameworks using VanillaJS deepened my understanding of JavaScript's fundamental operation principles and browser rendering mechanisms. Directly handling Canvas API and SVG built low-level graphics rendering experience, strengthening crucial real-world frontend development capabilities like real-time data processing via WebSocket, memory management, and performance optimization. Particularly designing and implementing state management patterns myself helped me understand how state management libraries provided by React or Vue work internally, enabling deeper utilization when later using Redux or Vuex. Solving memory leak and rendering performance issues taught me profiling techniques using Chrome DevTools, and I gained valuable experience applying optimization patterns frequently used in practice like requestAnimationFrame, Debouncing, and Observer pattern. Through Canvas-based data visualization, I learned efficient methods for representing large datasets, which greatly helped when implementing charts or graphs in subsequent projects.",
        "improvement": "Developing with VanillaJS made me acutely feel the necessity of frameworks. Without convenience features modern frameworks provide—component reusability, declarative UI, virtual DOM—implementing everything manually was slow and created much code duplication. Particularly manually managing data synchronization across modules and DOM update logic was cumbersome and frequently caused bugs from mistakes. Had I used React, state management could have been simply handled with useState or useReducer, and Canvas rendering managed with useEffect for much more concise code. Also, component-based structure could have separated charts, heatmaps, and movements into independent components for improved reusability and testability. In the project's latter half, I thought 'React would have been right for this scale.' I realized VanillaJS is suitable for small-scale interactive elements or legacy system maintenance, but has limits for building complex SPAs. In future similar projects, I learned the importance of considering project scale and complexity when choosing technology to select appropriate frameworks. Next time, I want to build a better structured data visualization dashboard using a React + D3.js combination."
      }
    }
  }
}
